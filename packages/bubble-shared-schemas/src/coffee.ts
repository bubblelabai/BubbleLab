import { z } from 'zod';

// ============================================================================
// Coffee Agent - Planning Phase for BubbleFlow Generation
// ============================================================================
// Coffee runs BEFORE Boba to gather clarification and generate an
// implementation plan. This helps reduce ambiguity in user requests.

// Constants
export const COFFEE_MAX_ITERATIONS = 5;
export const COFFEE_MAX_QUESTIONS = 3;
export const COFFEE_DEFAULT_MODEL = 'google/gemini-2.5-pro' as const;

// ============================================================================
// Clarification Schemas
// ============================================================================

/** A single choice option for a clarification question */
export const ClarificationChoiceSchema = z.object({
  id: z.string().describe('Unique identifier for this choice'),
  label: z.string().describe('Short display label for the choice'),
  description: z
    .string()
    .optional()
    .describe('Optional longer description explaining the choice'),
});

/** A clarification question with multiple choices */
export const ClarificationQuestionSchema = z.object({
  id: z.string().describe('Unique identifier for this question'),
  question: z.string().describe('The question text to display to the user'),
  choices: z
    .array(ClarificationChoiceSchema)
    .min(2)
    .max(4)
    .describe('Available choices for the user (2-4 options)'),
  context: z
    .string()
    .optional()
    .describe('Optional context explaining why this question is being asked'),
});

/** Event sent to frontend containing clarification questions */
export const CoffeeClarificationEventSchema = z.object({
  questions: z
    .array(ClarificationQuestionSchema)
    .min(1)
    .max(COFFEE_MAX_QUESTIONS)
    .describe('List of clarification questions (1-3)'),
});

// ============================================================================
// Context Gathering Schemas (Mocked for Phase 1)
// ============================================================================

/** Event for context gathering status */
export const CoffeeContextEventSchema = z.object({
  status: z
    .enum(['gathering', 'complete'])
    .describe('Current status of context gathering'),
  miniFlowDescription: z
    .string()
    .optional()
    .describe('Description of the mini flow that would run to gather context'),
  result: z
    .string()
    .optional()
    .describe('Result of context gathering (NOT_AVAILABLE in Phase 1)'),
});

// ============================================================================
// Plan Schemas
// ============================================================================

/** A single step in the implementation plan */
export const PlanStepSchema = z.object({
  title: z.string().describe('Short title for this step'),
  description: z
    .string()
    .describe('Detailed description of what this step does'),
  bubblesUsed: z
    .array(z.string())
    .optional()
    .describe('Names of bubbles used in this step'),
});

/** The complete implementation plan generated by Coffee */
export const CoffeePlanEventSchema = z.object({
  summary: z.string().describe('Brief overview of the workflow'),
  steps: z.array(PlanStepSchema).describe('Step-by-step implementation plan'),
  estimatedBubbles: z
    .array(z.string())
    .describe('All bubbles that will be used in the workflow'),
});

// ============================================================================
// Request/Response Schemas
// ============================================================================

/** Request to the Coffee agent */
export const CoffeeRequestSchema = z.object({
  prompt: z.string().min(1).describe('The user prompt describing the workflow'),
  flowId: z
    .number()
    .optional()
    .describe('Optional flow ID if updating existing flow'),
  clarificationAnswers: z
    .record(z.string(), z.array(z.string()))
    .optional()
    .describe(
      'User answers to previous clarification questions (questionId -> choiceIds)'
    ),
  planContext: z
    .string()
    .optional()
    .describe('Previously generated plan context (for building phase)'),
});

/** Response from the Coffee agent */
export const CoffeeResponseSchema = z.object({
  type: z
    .enum(['clarification', 'plan', 'error'])
    .describe(
      'Response type: clarification (needs user input), plan (ready for approval), error (failed)'
    ),
  clarification: CoffeeClarificationEventSchema.optional().describe(
    'Clarification questions (only when type is "clarification")'
  ),
  plan: CoffeePlanEventSchema.optional().describe(
    'Implementation plan (only when type is "plan")'
  ),
  error: z
    .string()
    .optional()
    .describe('Error message (only when type is "error")'),
  success: z.boolean().describe('Whether the operation completed successfully'),
});

/** Internal output format from the Coffee AI agent */
export const CoffeeAgentOutputSchema = z.object({
  action: z
    .enum(['askClarification', 'generatePlan'])
    .describe('The action the agent wants to take'),
  questions: z
    .array(ClarificationQuestionSchema)
    .optional()
    .describe('Questions to ask (when action is askClarification)'),
  plan: CoffeePlanEventSchema.optional().describe(
    'Generated plan (when action is generatePlan)'
  ),
});

// ============================================================================
// Type Exports
// ============================================================================

export type ClarificationChoice = z.infer<typeof ClarificationChoiceSchema>;
export type ClarificationQuestion = z.infer<typeof ClarificationQuestionSchema>;
export type CoffeeClarificationEvent = z.infer<
  typeof CoffeeClarificationEventSchema
>;
export type CoffeeContextEvent = z.infer<typeof CoffeeContextEventSchema>;
export type PlanStep = z.infer<typeof PlanStepSchema>;
export type CoffeePlanEvent = z.infer<typeof CoffeePlanEventSchema>;
export type CoffeeRequest = z.infer<typeof CoffeeRequestSchema>;
export type CoffeeResponse = z.infer<typeof CoffeeResponseSchema>;
export type CoffeeAgentOutput = z.infer<typeof CoffeeAgentOutputSchema>;
