import { z } from 'zod';
import {
  BubbleFlow,
  GoogleDriveBubble,
  AIAgentBubble,
  SlackBubble,
} from '@bubblelab/bubble-core';
import type { SlackMentionEvent } from '@bubblelab/shared-schemas';

/**
 * Input payload for the Slack Knowledge Base Bot.
 */
export interface SlackBotPayload extends SlackMentionEvent {
  /**
   * The Google Doc ID used as the knowledge base. Click the Google Drive icon to select a document.
   * @canBeGoogleFile true
   * @canBeFile false
   */
  knowledgeBaseDocId?: string;
}

/**
 * Output of the Slack bot knowledge base workflow.
 */
export interface Output {
  /** The final answer generated by the AI. */
  answer: string;
  /** The Slack channel where the reply was sent. */
  channel: string;
  /** The timestamp of the reply message. */
  timestamp: string;
}

/**
 * A Slack bot that answers questions based on a specific internal Google Doc.
 * It triggers when the bot is mentioned, reads the document content,
 * and provides a threaded response using AI.
 */
export class SlackBotKnowledgeBaseFlow extends BubbleFlow<'slack/bot_mentioned'> {
  async handle(payload: SlackBotPayload): Promise<Output> {
    const {
      knowledgeBaseDocId = '1Eqxm6wMmB9AQkKjULK7eafW53WVDRnDhWBWZVdcl5X0',
    } = payload;

    const { text: userQuestion, channel, thread_ts, slack_event } = payload;

    // Downloads the knowledge base document content as plain text
    const docContent = await this.downloadKnowledgeBase(knowledgeBaseDocId);

    // Generates a relevant answer using the document content as context
    const answer = await this.generateAnswer(userQuestion, docContent);

    // Posts the generated answer back to Slack in the original thread
    const replyTs = await this.replyInSlack(
      channel,
      answer,
      thread_ts || slack_event.event.ts
    );

    return {
      answer,
      channel,
      timestamp: replyTs,
    };
  }

  // Downloads the specified Google Doc as plain text to provide context for the AI agent.
  private async downloadKnowledgeBase(fileId: string): Promise<string> {
    // Downloads the Google Doc and exports it as plain text. This ensures the AI receives
    // clean, readable content without formatting overhead. The export_format parameter
    // is set to 'text/plain' specifically for Google Docs compatibility.
    const downloadBubble = new GoogleDriveBubble({
      operation: 'download_file',
      file_id: fileId,
      export_format: 'text/plain',
    });

    const result = await downloadBubble.action();

    if (!result.success || !result.data?.content) {
      throw new Error(
        `Failed to download knowledge base: ${result.error || 'No content found'}`
      );
    }

    return result.data.content;
  }

  // Processes the user's question against the document content using a high-reasoning AI model.
  private async generateAnswer(
    question: string,
    context: string
  ): Promise<string> {
    // Uses gemini-3-pro-preview to analyze the provided document content and answer the user's
    // specific question. The system prompt restricts the AI to only use the provided context,
    // ensuring accuracy and preventing hallucinations. Temperature is set to 0 for consistent,
    // factual responses based strictly on the internal documentation.
    const aiAgent = new AIAgentBubble({
      message: question,
      systemPrompt: `You are a helpful internal assistant. Answer the user's question based ONLY on the following document content. If the answer is not in the document, politely say you don't know.\n\nDOCUMENT CONTENT:\n${context}`,
      model: {
        model: 'google/gemini-3-pro-preview',
        temperature: 0,
        maxTokens: 2000,
      },
    });

    const result = await aiAgent.action();

    if (!result.success || !result.data?.response) {
      throw new Error(
        `AI Agent failed to generate answer: ${result.error || 'No response'}`
      );
    }

    return result.data.response;
  }

  // Sends the generated answer back to the Slack channel as a threaded reply.
  private async replyInSlack(
    channel: string,
    text: string,
    threadTs: string
  ): Promise<string> {
    // Posts the AI's response to the specified Slack channel. By providing the thread_ts,
    // the message appears as a reply to the original mention, keeping the channel conversation
    // organized. Returns the timestamp of the new message for tracking purposes.
    const slackBubble = new SlackBubble({
      operation: 'send_message',
      channel: channel,
      text: text,
      thread_ts: threadTs,
    });

    const result = await slackBubble.action();

    if (!result.success || !result.data?.ts) {
      throw new Error(`Failed to send Slack reply: ${result.error}`);
    }

    return result.data.ts;
  }
}
