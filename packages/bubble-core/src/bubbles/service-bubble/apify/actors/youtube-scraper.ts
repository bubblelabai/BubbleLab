import { z } from 'zod';

// ============================================================================
// YOUTUBE SCRAPER SCHEMAS
// ============================================================================

export const YouTubeScraperInputSchema = z.object({
  searchQueries: z
    .array(z.string())
    .optional()
    .describe(
      'Search terms to find YouTube videos. Enter search terms just like you would in YouTube search bar.'
    ),

  startUrls: z
    .array(z.object({ url: z.string().url() }))
    .optional()
    .default([])
    .describe(
      'Direct URLs to YouTube videos, channels, playlists, hashtags, or search results. Note: searchQueries will be ignored when using this option.'
    ),

  maxResults: z
    .number()
    .min(0)
    .optional()
    .default(0)
    .describe(
      'Maximum number of regular videos to scrape per search term or channel. 0 means no limit.'
    ),

  maxResultsShorts: z
    .number()
    .min(0)
    .optional()
    .default(0)
    .describe('Maximum number of YouTube Shorts to scrape. 0 means no limit.'),

  maxResultStreams: z
    .number()
    .min(0)
    .optional()
    .default(0)
    .describe(
      'Maximum number of stream/live videos to scrape. 0 means no limit.'
    ),

  downloadSubtitles: z
    .boolean()
    .optional()
    .default(false)
    .describe('Download subtitles for videos and convert them to .srt format'),

  saveSubsToKVS: z
    .boolean()
    .optional()
    .default(false)
    .describe(
      'Save downloaded subtitles to key-value store. Requires downloadSubtitles to be enabled.'
    ),

  subtitlesLanguage: z
    .enum(['any', 'en', 'de', 'es', 'fr', 'it', 'ja', 'ko', 'nl', 'pt', 'ru'])
    .optional()
    .default('en')
    .describe('Language for subtitles download'),

  preferAutoGeneratedSubtitles: z
    .boolean()
    .optional()
    .default(false)
    .describe(
      'Prefer automatically generated subtitles over user-created ones'
    ),

  subtitlesFormat: z
    .enum(['srt', 'vtt', 'xml', 'plaintext'])
    .optional()
    .default('srt')
    .describe('Format for downloaded subtitles'),

  sortingOrder: z
    .enum(['relevance', 'rating', 'date', 'views'])
    .optional()
    .describe('Sorting parameter for search results'),

  dateFilter: z
    .enum(['hour', 'today', 'week', 'month', 'year'])
    .optional()
    .describe('Upload date filter for search results'),

  videoType: z
    .enum(['video', 'movie'])
    .optional()
    .describe('Video type filter for search'),

  lengthFilter: z
    .enum(['under4', 'between420', 'plus20'])
    .optional()
    .describe(
      'Video length filter: under4 (under 4 min), between420 (4-20 min), plus20 (over 20 min)'
    ),

  isHD: z.boolean().optional().describe('Filter for HD videos only'),

  hasSubtitles: z
    .boolean()
    .optional()
    .describe('Filter for videos with subtitles/CC'),

  hasCC: z.boolean().optional().describe('Filter for Creative Commons videos'),

  is3D: z.boolean().optional().describe('Filter for 3D videos'),

  isLive: z.boolean().optional().describe('Filter for live videos'),

  isBought: z.boolean().optional().describe('Filter for purchased videos'),

  is4K: z.boolean().optional().describe('Filter for 4K videos'),

  is360: z.boolean().optional().describe('Filter for 360-degree videos'),

  hasLocation: z
    .boolean()
    .optional()
    .describe('Filter for videos with location'),

  isHDR: z.boolean().optional().describe('Filter for HDR videos'),

  isVR180: z.boolean().optional().describe('Filter for VR180 videos'),

  oldestPostDate: z
    .string()
    .optional()
    .describe(
      'Only scrape videos published after this date (YYYY-MM-DD) or number of days (e.g., "1" for today only)'
    ),

  sortVideosBy: z
    .enum(['NEWEST', 'POPULAR', 'OLDEST'])
    .optional()
    .describe('Sorting for channel videos, shorts, and live streams'),
});

export const YouTubeVideoSchema = z.object({
  title: z.string().optional().describe('Video title'),

  id: z.string().optional().describe('YouTube video ID'),

  url: z.string().optional().describe('Video URL'),

  viewCount: z.number().optional().describe('Number of views'),

  date: z.string().optional().describe('Upload date (ISO format)'),

  likes: z.number().optional().describe('Number of likes'),

  channelName: z.string().optional().describe('Channel name'),

  channelUrl: z.string().optional().describe('Channel URL'),

  numberOfSubscribers: z
    .number()
    .optional()
    .describe('Number of channel subscribers'),

  duration: z.string().optional().describe('Video duration (HH:MM:SS format)'),

  description: z.string().optional().describe('Video description'),

  text: z
    .string()
    .optional()
    .describe('Video description text (Apify field name)'),

  comments: z.number().optional().describe('Number of comments'),

  commentsCount: z
    .number()
    .optional()
    .describe('Number of comments (Apify field name)'),

  thumbnail: z.string().optional().describe('Video thumbnail URL'),

  thumbnailUrl: z
    .string()
    .optional()
    .describe('Video thumbnail URL (Apify field name)'),

  videoType: z
    .string()
    .optional()
    .describe('Type of video (regular, short, stream)'),

  tags: z.array(z.string()).optional().describe('Video tags'),

  category: z.string().optional().describe('Video category'),

  isLive: z.boolean().optional().describe('Whether video is a live stream'),

  subtitles: z
    .array(
      z.object({
        language: z.string().optional(),
        url: z.string().optional(),
        text: z.string().optional(),
      })
    )
    .optional()
    .describe('Video subtitles (if downloadSubtitles is enabled)'),
});
