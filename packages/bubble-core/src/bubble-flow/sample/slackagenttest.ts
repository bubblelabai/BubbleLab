import type { BubbleTriggerEventRegistry } from '@bubblelab/shared-schemas';
import {
  BubbleFlow,
  DatabaseAnalyzerWorkflowBubble,
  AIAgentBubble,
  PostgreSQLBubble,
  SlackNotifierWorkflowBubble,
} from '@bubblelab/bubble-core';

// Import all services

export interface Output {
  message: string;
}

// This is a test bubble flow that is used to test the bubble flow system
export class TestBubbleFlow extends BubbleFlow<'webhook/http'> {
  constructor() {
    super('test-flow', 'A flow that handles webhook events');
  }
  async handle(
    payload: BubbleTriggerEventRegistry['webhook/http']
  ): Promise<Output> {
    const schemaAnalysis = await new DatabaseAnalyzerWorkflowBubble({
      dataSourceType: 'postgresql',
      ignoreSSLErrors: true,
      includeMetadata: true,
    }).action();

    const sqlQueryResult = await new AIAgentBubble({
      message: payload.body?.userQuery as string,
      systemPrompt: `You are a helpful assistant that writes PostgreSQL queries.

Using this database schema: ${schemaAnalysis.data?.databaseSchema?.cleanedJSON}

Write a SQL query to answer the user's question. Return only the query between \`\`\`sql\`\`\` blocks, no other text.`,
      model: {
        model: 'google/gemini-2.5-pro',
        maxTokens: 5000,
      },
    }).action();

    // Extract clean SQL query from AI response
    const sqlMatch = sqlQueryResult.data?.response?.match(
      /```(?:sql|postgresql)\n([\s\S]*?)\n```/
    );
    const cleanQuery = sqlMatch ? sqlMatch[1].trim() : null;

    if (!cleanQuery) {
      throw new Error('No valid SQL query generated by AI');
    }

    const queryResult = await new PostgreSQLBubble({
      query: cleanQuery,
      ignoreSSL: true,
      allowedOperations: ['SELECT'], // Safety first!
      timeout: 30000,
      maxRows: 1000,
    }).action();

    if (!queryResult.success) {
      throw new Error(`Query execution failed: ${queryResult.error}`);
    }

    const slackNotification = await new SlackNotifierWorkflowBubble({
      contentToFormat: JSON.stringify(queryResult.data, null, 2),
      originalUserQuery: payload.body?.userQuery as string,
      targetChannel: 'staging-bot',
      messageTitle: 'ðŸ“Š Automated Data Analysis Results',
      messageStyle: 'professional',
      includeFormatting: true,
      maxMessageLength: 3000,
      aiModel: {
        model: 'google/gemini-2.5-flash',
        temperature: 0.3,
      },
    }).action();

    return {
      message: `Response from ${payload.path}, ${payload.timestamp}, ${payload.type}: ${slackNotification.data?.messageInfo?.formattedMessage} Analysis complete!`,
    };
  }
}
