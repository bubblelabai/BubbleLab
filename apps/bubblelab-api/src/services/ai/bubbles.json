{
  "version": "1.0.0",
  "generatedAt": "2025-10-13T11:36:22.090Z",
  "totalCount": 32,
  "bubbles": [
    {
      "name": "hello-world",
      "alias": "hello",
      "type": "service",
      "shortDescription": "Simple hello world bubble for testing purposes",
      "useCase": "- Testing the bubble execution system",
      "inputSchema": "{\n  name: string // Name to include in the greeting message,\n  message: string | undefined // Custom greeting message,\n  credentials: Record<string, string> | undefined // Object mapping credential types to values (injected at runtime)\n}",
      "outputSchema": "{\n  greeting: string // The generated greeting message,\n  success: boolean // Whether the operation was successful,\n  error: string // Error message if operation failed\n}",
      "usageExample": "// Example usage of hello-world bubble\nconst helloWorld = new HelloWorldBubble({\n  name: \"example string\", // Name to include in the greeting message,\n  message: \"Hello from NodeX!\" // default, // Custom greeting message,\n});\n\nconst result = await helloWorld.action();\n\n// Always check success status before using data\nif (!result.success) {\n  throw new Error(`${metadata.name} failed: ${result.error}`);\n}\n\n// Expected output structure in result.data:\n// { greeting: \"example string\" // The generated greeting message, success: true // Whether the operation was successful, error: \"example string\" // Error message if operation failed }\n\n// Access the actual data\nconst actualData = result.data;\nconsole.log(actualData);",
      "requiredCredentials": []
    },
    {
      "name": "ai-agent",
      "alias": "agent",
      "type": "service",
      "shortDescription": "AI agent with LangGraph for tool-enabled conversations, multimodal support, and JSON mode",
      "useCase": "- Add tools to enhance the AI agent's capabilities (web-search-tool, web-scrape-tool)",
      "inputSchema": "{\n  message: string // The message or question to send to the AI agent,\n  images: DiscriminatedUnion[] // Array of base64 encoded images to include with the message (for multimodal AI models). Example: [{type: \"base64\", data: \"base64...\", mimeType: \"image/png\", description: \"A beautiful image of a cat\"}] or [{type: \"url\", url: \"https://example.com/image.png\", description: \"A beautiful image of a cat\"}],\n  systemPrompt: string // System prompt that defines the AI agents behavior and personality,\n  name: string | undefined // A friendly name for the AI agent,\n  model: { model: \"openai/gpt-5\" | \"openai/gpt-5-mini\" | \"openai/gpt-o4-mini\" | \"openai/gpt-4o\" | \"google/gemini-2.5-pro\" | \"google/gemini-2.5-flash\" | \"google/gemini-2.5-flash-lite\" | \"google/gemini-2.5-flash-image-preview\" | \"anthropic/claude-sonnet-4-5-20250929\", temperature: number, maxTokens: number | undefined, jsonMode: boolean } // AI model configuration including provider, temperature, and tokens. For model unless otherwise specified, use google/gemini-2.5-flash as default. Use google/gemini-2.5-flash-image-preview to edit and generate images.,\n  tools: { name: \"web-search-tool\" | \"web-scrape-tool\" | \"web-crawl-tool\" | \"web-extract-tool\" | \"research-agent-tool\" | \"reddit-scrape-tool\" | \"list-bubbles-tool\" | \"get-bubble-details-tool\" | \"bubbleflow-validation-tool\" | \"chart-js-tool\" | \"sql-query-tool\", credentials: Record<string, string> | undefined, config: Record<string, unknown> | undefined }[] // Array of tools the AI agent can use. Can be tool types (web-search-tool, web-scrape-tool, web-crawl-tool, web-extract-tool). If using image models, set the tools to [],\n  maxIterations: number // Maximum number of iterations for the agent workflow,\n  credentials: Record<string, string> | undefined // Object mapping credential types to values (injected at runtime),\n  streaming: boolean // Enable real-time streaming of tokens, tool calls, and iteration progress\n}",
      "outputSchema": "{\n  response: string // The AI agents final response to the user message. For text responses, returns plain text or JSON string. For image generation models (like gemini-2.5-flash-image-preview), returns base64-encoded image data with data URI format (data:image/png;base64,...),\n  toolCalls: { tool: string, input: unknown, output: unknown }[] // Array of tool calls made during the conversation,\n  iterations: number // Number of back-and-forth iterations in the agent workflow,\n  error: string // Error message of the run, undefined if successful,\n  success: boolean // Whether the agent execution completed successfully\n}",
      "usageExample": "// Example usage of ai-agent bubble\nconst aiAgent = new AiAgentBubble({\n  message: \"example string\", // The message or question to send to the AI agent,\n  images: [{ type: \"base64\" // default, data: \"example string\", mimeType: \"image/png\" // default, description: \"example string\" }] // example for array, // Array of base64 encoded images to include with the message (for multimodal AI models). Example: [{type: \"base64\", data: \"base64...\", mimeType: \"image/png\", description: \"A beautiful image of a cat\"}] or [{type: \"url\", url: \"https://example.com/image.png\", description: \"A beautiful image of a cat\"}],\n  systemPrompt: \"You are a helpful AI assistant\" // default, // System prompt that defines the AI agents behavior and personality,\n  name: \"AI Agent\" // default, // A friendly name for the AI agent,\n  model: { model: \"openai/gpt-5\" // options: \"openai/gpt-5\", \"openai/gpt-5-mini\", \"openai/gpt-o4-mini\", \"openai/gpt-4o\", \"google/gemini-2.5-pro\", \"google/gemini-2.5-flash\", \"google/gemini-2.5-flash-lite\", \"google/gemini-2.5-flash-image-preview\", \"anthropic/claude-sonnet-4-5-20250929\" // AI model to use (format: provider/model-name)., temperature: 0.7 // default // Temperature for response randomness (0 = deterministic, 2 = very random), maxTokens: 40000 // default // Maximum number of tokens to generate in response, jsonMode: false // default // When true, strips markdown formatting and returns clean JSON response } // structure, // AI model configuration including provider, temperature, and tokens. For model unless otherwise specified, use google/gemini-2.5-flash as default. Use google/gemini-2.5-flash-image-preview to edit and generate images.,\n  tools: [{\"name\":\"web-search-tool\",\"config\":{\"maxResults\":5}}] // default, // Array of tools the AI agent can use. Can be tool types (web-search-tool, web-scrape-tool, web-crawl-tool, web-extract-tool). If using image models, set the tools to [],\n  maxIterations: 10 // default, // Maximum number of iterations for the agent workflow,\n  streaming: false // default, // Enable real-time streaming of tokens, tool calls, and iteration progress,\n});\n\nconst result = await aiAgent.action();\n\n// Always check success status before using data\nif (!result.success) {\n  throw new Error(`${metadata.name} failed: ${result.error}`);\n}\n\n// Expected output structure in result.data:\n// { response: \"example string\" // The AI agents final response to the user message. For text responses, returns plain text or JSON string. For image generation models (like gemini-2.5-flash-image-preview), returns base64-encoded image data with data URI format (data:image/png;base64,...), toolCalls: [{ tool: \"example string\" // Name of the tool that was called }] // Array of tool calls made during the conversation, iterations: 42 // Number of back-and-forth iterations in the agent workflow, error: \"example string\" // Error message of the run, undefined if successful, success: true // Whether the agent execution completed successfully }\n\n// Access the actual data\nconst actualData = result.data;\nconsole.log(actualData);",
      "requiredCredentials": [
        "OPENAI_CRED",
        "GOOGLE_GEMINI_CRED",
        "ANTHROPIC_CRED",
        "FIRECRAWL_API_KEY"
      ]
    },
    {
      "name": "postgresql",
      "alias": "pg",
      "type": "service",
      "shortDescription": "Execute PostgreSQL queries with operation validation",
      "useCase": "- Data retrieval with SELECT queries",
      "inputSchema": "{\n  ignoreSSL: boolean // Ignore SSL certificate errors when connecting to the database,\n  query: unknown // SQL query to execute against the PostgreSQL database (use parameterized queries with $1, $2, etc.),\n  allowedOperations: \"SELECT\" | \"INSERT\" | \"UPDATE\" | \"DELETE\" | \"WITH\" | \"EXPLAIN\" | \"ANALYZE\" | \"SHOW\" | \"DESCRIBE\" | \"DESC\" | \"CREATE\"[] // List of allowed SQL operations for security (defaults to read-only operations),\n  parameters: unknown[] | undefined // Parameters for parameterized queries (e.g., [value1, value2] for $1, $2),\n  timeout: number // Query timeout in milliseconds (default: 30 seconds, max recommended: 300000),\n  maxRows: number // Maximum number of rows to return to prevent large result sets (default: 1000),\n  credentials: Record<string, string> | undefined // Object mapping credential types to values (injected at runtime)\n}",
      "outputSchema": "{\n  rows: Record<string, unknown>[] // Array of result rows, each row is an object with column names as keys,\n  rowCount: unknown // Number of rows affected by the query (null for SELECT queries),\n  command: string // SQL command that was executed (SELECT, INSERT, UPDATE, DELETE),\n  fields: { name: string, dataTypeID: number }[] | undefined // Metadata about the columns returned by the query,\n  executionTime: number // Query execution time in milliseconds,\n  success: boolean // Whether the query executed successfully,\n  error: string // Error message if query execution failed (empty string if successful),\n  cleanedJSONString: string // Clean JSON string representation of the row data, suitable for AI prompts and integrations\n}",
      "usageExample": "// Example usage of postgresql bubble\nconst postgresql = new PostgresqlBubble({\n  ignoreSSL: true // default, // Ignore SSL certificate errors when connecting to the database,\n  allowedOperations: [\"SELECT\",\"WITH\",\"EXPLAIN\",\"ANALYZE\",\"SHOW\",\"DESCRIBE\",\"DESC\"] // default, // List of allowed SQL operations for security (defaults to read-only operations),\n  parameters: [] // default, // Parameters for parameterized queries (e.g., [value1, value2] for $1, $2),\n  timeout: 30000 // default, // Query timeout in milliseconds (default: 30 seconds, max recommended: 300000),\n  maxRows: 1000 // default, // Maximum number of rows to return to prevent large result sets (default: 1000),\n});\n\nconst result = await postgresql.action();\n\n// Always check success status before using data\nif (!result.success) {\n  throw new Error(`${metadata.name} failed: ${result.error}`);\n}\n\n// Expected output structure in result.data:\n// { rows: [{} // record/object with string keys] // Array of result rows, each row is an object with column names as keys, command: \"example string\" // SQL command that was executed (SELECT, INSERT, UPDATE, DELETE), fields: [{ name: \"example string\" // Column name, dataTypeID: 42 // PostgreSQL data type identifier }] // Metadata about the columns returned by the query, executionTime: 42 // Query execution time in milliseconds, success: true // Whether the query executed successfully, error: \"example string\" // Error message if query execution failed (empty string if successful), cleanedJSONString: \"example string\" // Clean JSON string representation of the row data, suitable for AI prompts and integrations }\n\n// Access the actual data\nconst actualData = result.data;\nconsole.log(actualData);",
      "requiredCredentials": ["DATABASE_CRED"]
    },
    {
      "name": "slack",
      "alias": "slack",
      "type": "service",
      "shortDescription": "Slack integration for messaging and workspace management",
      "useCase": "- Send messages to channels or direct messages",
      "inputSchema": "Complex schema - see usage example for structure",
      "outputSchema": "Complex schema - see usage example for structure",
      "usageExample": "// Send Message example\nconst slack_send_message = new SlackBubble({\n  operation: \"send_message\", // Send a message to a Slack channel or DM\n  channel: \"example string\", // Channel ID (e.g., C1234567890), channel name (e.g., general or #general), or user ID for DM\n  text: \"example string\", // Message text content\n  username: \"example string\", // Override bot username for this message\n  icon_emoji: \"example string\", // Override bot icon with emoji (e.g., :robot_face:)\n  icon_url: \"example string\", // Override bot icon with custom image URL\n  attachments: [{ color: \"example string\" // Color bar accent (hex color or good/warning/danger), pretext: \"example string\" // Text that appears before the main attachment content, author_name: \"example string\" // Author name displayed at the top, author_link: \"example string\" // URL to link the author name, author_icon: \"example string\" // Author icon image URL, title: \"example string\" // Attachment title text, title_link: \"example string\" // URL to link the title, text: \"example string\" // Main attachment text content, fields: [{ title: \"example string\" // Field title, value: \"example string\" // Field value, short: true // Whether field should be displayed side-by-side }] // Array of field objects for structured data, image_url: \"example string\" // URL of image to display, thumb_url: \"example string\" // URL of thumbnail image, footer: \"example string\" // Footer text, footer_icon: \"example string\" // Footer icon URL, ts: 42 // Timestamp for the attachment }], // Legacy message attachments\n  blocks: [{ type: \"example string\" // Block element type (section, divider, button, etc.), text: { type: \"plain_text\" // options: \"plain_text\", \"mrkdwn\" // Text formatting type, text: \"example string\" // The actual text content, emoji: true, verbatim: true } // Text object for the block element, elements: [{ type: \"plain_text\" // options: \"plain_text\", \"mrkdwn\", \"image\" // Element type, text: \"example string\" // Text content, image_url: \"example string\" // Image URL for image elements, alt_text: \"example string\" // Alt text for image elements, emoji: true, verbatim: true }] // Elements array for context blocks }], // Block Kit structured message blocks\n  thread_ts: \"example string\", // Timestamp of parent message to reply in thread\n  reply_broadcast: false // default, // Broadcast thread reply to channel\n  unfurl_links: true // default, // Enable automatic link unfurling\n  unfurl_media: true // default, // Enable automatic media unfurling\n});\n\nconst result = await slack_send_message.action();\n\n// List Channels example\nconst slack_list_channels = new SlackBubble({\n  operation: \"list_channels\", // List all channels in the Slack workspace\n  types: [\"public_channel\",\"private_channel\"] // default, // Types of channels to include in results\n  exclude_archived: true // default, // Exclude archived channels from results\n  limit: 50 // default, // Maximum number of channels to return (1-1000)\n  cursor: \"example string\", // Cursor for pagination to get next set of results\n});\n\nconst result = await slack_list_channels.action();\n\n// Get Channel Info example\nconst slack_get_channel_info = new SlackBubble({\n  operation: \"get_channel_info\", // Get detailed information about a specific channel\n  channel: \"example string\", // Channel ID (e.g., C1234567890) or channel name (e.g., general or #general)\n  include_locale: false // default, // Include locale information in the response\n});\n\nconst result = await slack_get_channel_info.action();\n\n// Get User Info example\nconst slack_get_user_info = new SlackBubble({\n  operation: \"get_user_info\", // Get detailed information about a specific user\n  user: \"example string\", // User ID to get information about\n  include_locale: false // default, // Include locale information in the response\n});\n\nconst result = await slack_get_user_info.action();\n\n// Always check success status before using data\nif (!result.success) {\n  throw new Error(`slack failed: ${result.error}`);\n}\n\n// Access the actual data\nconst actualData = result.data;\nconsole.log(actualData);\n\n// ... and 8 more operations available",
      "requiredCredentials": ["SLACK_CRED"]
    },
    {
      "name": "resend",
      "alias": "resend",
      "type": "service",
      "shortDescription": "Email sending service via Resend API",
      "useCase": "- Send transactional emails with HTML and text content",
      "inputSchema": "Complex schema - see usage example for structure",
      "outputSchema": "Complex schema - see usage example for structure",
      "usageExample": "// Send Email example\nconst resend_send_email = new ResendBubble({\n  operation: \"send_email\", // Send an email via Resend\n  from: \"Bubble Lab Team <welcome@hello.bubblelab.ai>\" // default, // Sender email address (defaults to Bubble Lab Team if not provided)\n  subject: \"example string\", // Email subject line\n  text: \"example string\", // Plain text email content\n  html: \"example string\", // HTML email content\n  scheduled_at: \"example string\", // Schedule email to be sent later (ISO 8601 format or natural language like \"in 1 hour\")\n  attachments: [{ filename: \"example string\" // Name of the attached file, content_type: \"example string\" // MIME type of the file, path: \"example string\" // Path where the attachment file is hosted }], // Array of email attachments (max 40MB total per email)\n  tags: [{ name: \"example string\" // Tag name (ASCII letters, numbers, underscores, dashes only, max 256 chars), value: \"example string\" // Tag value (ASCII letters, numbers, underscores, dashes only, max 256 chars) }], // Array of email tags for tracking and analytics\n  headers: { \"example_key\": \"example string\" } // record/object with string keys, // Custom email headers (e.g., X-Custom-Header)\n});\n\nconst result = await resend_send_email.action();\n\n// Get Email Status example\nconst resend_get_email_status = new ResendBubble({\n  operation: \"get_email_status\", // Get the status of a sent email\n  email_id: \"example string\", // Resend email ID to check status for\n});\n\nconst result = await resend_get_email_status.action();\n\n// Always check success status before using data\nif (!result.success) {\n  throw new Error(`resend failed: ${result.error}`);\n}\n\n// Access the actual data\nconst actualData = result.data;\nconsole.log(actualData);",
      "requiredCredentials": ["RESEND_CRED"]
    },
    {
      "name": "http",
      "alias": "fetch",
      "type": "service",
      "shortDescription": "Makes HTTP requests to external APIs and services",
      "useCase": "- Calling external REST APIs",
      "inputSchema": "{\n  url: string // The URL to make the HTTP request to,\n  method: \"GET\" | \"POST\" | \"PUT\" | \"PATCH\" | \"DELETE\" | \"HEAD\" | \"OPTIONS\" // HTTP method to use (default: GET),\n  headers: Record<string, string> | undefined // HTTP headers to include in the request,\n  body: unknown | undefined // Request body (string or JSON object),\n  timeout: number // Request timeout in milliseconds (default: 30000, max: 120000),\n  followRedirects: boolean // Whether to follow HTTP redirects (default: true),\n  credentials: Record<string, string> | undefined // Optional credentials for authentication (injected at runtime)\n}",
      "outputSchema": "{\n  status: number // HTTP status code,\n  statusText: string // HTTP status text,\n  headers: Record<string, string> // Response headers,\n  body: string // Response body as string,\n  json: unknown | undefined // Parsed JSON response (if applicable),\n  success: boolean // Whether the request was successful (HTTP 2xx status codes),\n  error: string // Error message if request failed,\n  responseTime: number // Response time in milliseconds,\n  size: number // Response size in bytes\n}",
      "usageExample": "// Example usage of http bubble\nconst http = new HttpBubble({\n  url: \"example string\", // The URL to make the HTTP request to,\n  method: \"GET\" // options: \"GET\", \"POST\", \"PUT\", \"PATCH\", \"DELETE\", \"HEAD\", \"OPTIONS\", // HTTP method to use (default: GET),\n  headers: { \"example_key\": \"example string\" } // record/object with string keys, // HTTP headers to include in the request,\n  timeout: 30000 // default, // Request timeout in milliseconds (default: 30000, max: 120000),\n  followRedirects: true // default, // Whether to follow HTTP redirects (default: true),\n});\n\nconst result = await http.action();\n\n// Always check success status before using data\nif (!result.success) {\n  throw new Error(`${metadata.name} failed: ${result.error}`);\n}\n\n// Expected output structure in result.data:\n// { status: 42 // HTTP status code, statusText: \"example string\" // HTTP status text, headers: { \"example_key\": \"example string\" } // record/object with string keys // Response headers, body: \"example string\" // Response body as string, success: true // Whether the request was successful (HTTP 2xx status codes), error: \"example string\" // Error message if request failed, responseTime: 42 // Response time in milliseconds, size: 42 // Response size in bytes }\n\n// Access the actual data\nconst actualData = result.data;\nconsole.log(actualData);",
      "requiredCredentials": []
    },
    {
      "name": "storage",
      "alias": "r2",
      "type": "service",
      "shortDescription": "Cloudflare R2 storage operations for file management",
      "useCase": "- Generate presigned upload URLs for client-side file uploads",
      "inputSchema": "Complex schema - see usage example for structure",
      "outputSchema": "Complex schema - see usage example for structure",
      "usageExample": "// GetUploadUrl example\nconst storage_getUploadUrl = new StorageBubble({\n  operation: \"getUploadUrl\", // Generate presigned upload URL\n  bucketName: \"example string\", // Name of the R2 bucket\n  fileName: \"example string\", // Original filename for the upload\n  accountId: \"example string\", // Cloudflare Account ID - can be provided via credentials\n  region: \"auto\" // default, // AWS region for R2 storage (defaults to auto)\n  expirationMinutes: 60 // default, // URL expiration time in minutes\n  contentType: \"example string\", // Content type for uploads\n  userId: \"example string\", // User ID for secure file isolation\n});\n\nconst result = await storage_getUploadUrl.action();\n\n// GetFile example\nconst storage_getFile = new StorageBubble({\n  operation: \"getFile\", // Generate presigned download URL\n  bucketName: \"example string\", // Name of the R2 bucket\n  fileName: \"example string\", // Name of the file to retrieve\n  accountId: \"example string\", // Cloudflare Account ID - can be provided via credentials\n  region: \"auto\" // default, // AWS region for R2 storage (defaults to auto)\n  expirationMinutes: 60 // default, // URL expiration time in minutes\n  userId: \"example string\", // User ID for secure file isolation\n});\n\nconst result = await storage_getFile.action();\n\n// DeleteFile example\nconst storage_deleteFile = new StorageBubble({\n  operation: \"deleteFile\", // Delete file from bucket\n  bucketName: \"example string\", // Name of the R2 bucket\n  fileName: \"example string\", // Name of the file to delete\n  accountId: \"example string\", // Cloudflare Account ID - can be provided via credentials\n  region: \"auto\" // default, // AWS region for R2 storage (defaults to auto)\n});\n\nconst result = await storage_deleteFile.action();\n\n// UpdateFile example\nconst storage_updateFile = new StorageBubble({\n  operation: \"updateFile\", // Update/replace file content\n  bucketName: \"example string\", // Name of the R2 bucket\n  fileName: \"example string\", // Name of the file to update\n  accountId: \"example string\", // Cloudflare Account ID - can be provided via credentials\n  region: \"auto\" // default, // AWS region for R2 storage (defaults to auto)\n  contentType: \"example string\", // Content type for uploads\n  fileContent: \"example string\", // Base64 encoded file content or raw text content\n});\n\nconst result = await storage_updateFile.action();\n\n// Always check success status before using data\nif (!result.success) {\n  throw new Error(`storage failed: ${result.error}`);\n}\n\n// Access the actual data\nconst actualData = result.data;\nconsole.log(actualData);\n\n// ... and 1 more operations available",
      "requiredCredentials": [
        "CLOUDFLARE_R2_ACCESS_KEY",
        "CLOUDFLARE_R2_SECRET_KEY",
        "CLOUDFLARE_R2_ACCOUNT_ID"
      ]
    },
    {
      "name": "google-drive",
      "alias": "gdrive",
      "type": "service",
      "shortDescription": "Google Drive integration for file management",
      "useCase": "- Upload files and documents to Google Drive",
      "inputSchema": "Complex schema - see usage example for structure",
      "outputSchema": "Complex schema - see usage example for structure",
      "usageExample": "// Upload File example\nconst googleDrive_upload_file = new GoogleDriveBubble({\n  operation: \"upload_file\", // Upload a file to Google Drive\n  name: \"example string\", // Name for the uploaded file\n  content: \"example string\", // File content as base64 encoded string or plain text\n  mimeType: \"example string\", // MIME type of the file (auto-detected if not provided)\n  parent_folder_id: \"example string\", // ID of the parent folder (uploads to root if not provided)\n  convert_to_google_docs: false // default, // Convert uploaded file to Google Docs format if possible\n});\n\nconst result = await googleDrive_upload_file.action();\n\n// Download File example\nconst googleDrive_download_file = new GoogleDriveBubble({\n  operation: \"download_file\", // Download a file from Google Drive\n  file_id: \"example string\", // Google Drive file ID to download\n  export_format: \"example string\", // Export format for Google Workspace files (e.g., \"application/pdf\", \"text/plain\")\n});\n\nconst result = await googleDrive_download_file.action();\n\n// List Files example\nconst googleDrive_list_files = new GoogleDriveBubble({\n  operation: \"list_files\", // List files and folders in Google Drive\n  folder_id: \"example string\", // ID of folder to list files from (lists from root if not provided)\n  query: \"example string\", // Search query to filter files (e.g., \"name contains 'report'\"\n  max_results: 100 // default, // Maximum number of files to return\n  include_folders: true // default, // Include folders in the results\n  order_by: \"modifiedTime desc\" // default, // Order results by field (e.g., \"name\", \"modifiedTime desc\")\n});\n\nconst result = await googleDrive_list_files.action();\n\n// Create Folder example\nconst googleDrive_create_folder = new GoogleDriveBubble({\n  operation: \"create_folder\", // Create a new folder in Google Drive\n  name: \"example string\", // Name of the folder to create\n  parent_folder_id: \"example string\", // ID of the parent folder (creates in root if not provided)\n});\n\nconst result = await googleDrive_create_folder.action();\n\n// Always check success status before using data\nif (!result.success) {\n  throw new Error(`google-drive failed: ${result.error}`);\n}\n\n// Access the actual data\nconst actualData = result.data;\nconsole.log(actualData);\n\n// ... and 3 more operations available",
      "requiredCredentials": ["GOOGLE_DRIVE_CRED"]
    },
    {
      "name": "gmail",
      "alias": "gmail",
      "type": "service",
      "shortDescription": "Gmail integration for email management",
      "useCase": "- Send and receive emails with rich formatting",
      "inputSchema": "Complex schema - see usage example for structure",
      "outputSchema": "Complex schema - see usage example for structure",
      "usageExample": "// Send Email example\nconst gmail_send_email = new GmailBubble({\n  operation: \"send_email\", // Send an email message\n  to: [\"example string\"], // List of recipient email addresses\n  cc: [\"example string\"], // List of CC recipient email addresses\n  bcc: [\"example string\"], // List of BCC recipient email addresses\n  subject: \"example string\", // Email subject line\n  body_text: \"example string\", // Plain text email body\n  body_html: \"example string\", // HTML email body\n  reply_to: \"example string\", // Reply-to email address\n  thread_id: \"example string\", // Thread ID to reply to (for threaded conversations)\n});\n\nconst result = await gmail_send_email.action();\n\n// List Emails example\nconst gmail_list_emails = new GmailBubble({\n  operation: \"list_emails\", // List emails in the user mailbox\n  query: \"example string\", // Gmail search query (e.g., \"from:user@example.com is:unread\")\n  label_ids: [\"example string\"], // Filter by specific label IDs\n  include_spam_trash: false // default, // Include messages from SPAM and TRASH\n  max_results: 100 // default, // Maximum number of messages to return\n  page_token: \"example string\", // Token for pagination to get next page\n});\n\nconst result = await gmail_list_emails.action();\n\n// Get Email example\nconst gmail_get_email = new GmailBubble({\n  operation: \"get_email\", // Get a specific email message\n  message_id: \"example string\", // Gmail message ID to retrieve\n  format: \"minimal\" // options: \"minimal\", \"full\", \"raw\", \"metadata\", // Format to return the message in\n  metadata_headers: [\"example string\"], // List of headers to include when format is metadata\n});\n\nconst result = await gmail_get_email.action();\n\n// Search Emails example\nconst gmail_search_emails = new GmailBubble({\n  operation: \"search_emails\", // Search emails with query\n  query: \"example string\", // Gmail search query string\n  max_results: 50 // default, // Maximum number of results to return\n  include_spam_trash: false // default, // Include messages from SPAM and TRASH\n});\n\nconst result = await gmail_search_emails.action();\n\n// Always check success status before using data\nif (!result.success) {\n  throw new Error(`gmail failed: ${result.error}`);\n}\n\n// Access the actual data\nconst actualData = result.data;\nconsole.log(actualData);\n\n// ... and 8 more operations available",
      "requiredCredentials": ["GMAIL_CRED"]
    },
    {
      "name": "google-sheets",
      "alias": "sheets",
      "type": "service",
      "shortDescription": "Google Sheets integration for spreadsheet operations",
      "useCase": "- Read and write spreadsheet data with flexible ranges",
      "inputSchema": "Complex schema - see usage example for structure",
      "outputSchema": "Complex schema - see usage example for structure",
      "usageExample": "// Read Values example\nconst googleSheets_read_values = new GoogleSheetsBubble({\n  operation: \"read_values\", // Read values from a range\n  spreadsheet_id: \"example string\", // Google Sheets spreadsheet ID\n  range: \"example string\", // A1 notation range (e.g., \"Sheet1!A1:B10\")\n  major_dimension: \"ROWS\" // options: \"ROWS\", \"COLUMNS\", // Major dimension for the values\n  value_render_option: \"FORMATTED_VALUE\" // options: \"FORMATTED_VALUE\", \"UNFORMATTED_VALUE\", \"FORMULA\", // How values should be represented in the output\n  date_time_render_option: \"SERIAL_NUMBER\" // options: \"SERIAL_NUMBER\", \"FORMATTED_STRING\", // How date/time values should be rendered\n});\n\nconst result = await googleSheets_read_values.action();\n\n// Write Values example\nconst googleSheets_write_values = new GoogleSheetsBubble({\n  operation: \"write_values\", // Write values to a range\n  spreadsheet_id: \"example string\", // Google Sheets spreadsheet ID\n  range: \"example string\", // A1 notation range (e.g., \"Sheet1!A1:B10\")\n  values: [[]], // Data to write as array of arrays\n  major_dimension: \"ROWS\" // options: \"ROWS\", \"COLUMNS\", // Major dimension for the values\n  value_input_option: \"RAW\" // options: \"RAW\", \"USER_ENTERED\", // How input data should be interpreted\n  include_values_in_response: false // default, // Include updated values in response\n});\n\nconst result = await googleSheets_write_values.action();\n\n// Update Values example\nconst googleSheets_update_values = new GoogleSheetsBubble({\n  operation: \"update_values\", // Update values in a specific range\n  spreadsheet_id: \"example string\", // Google Sheets spreadsheet ID\n  range: \"example string\", // A1 notation range (e.g., \"Sheet1!A1:B10\")\n  values: [[]], // Data to update as array of arrays\n  major_dimension: \"ROWS\" // options: \"ROWS\", \"COLUMNS\", // Major dimension for the values\n  value_input_option: \"RAW\" // options: \"RAW\", \"USER_ENTERED\", // How input data should be interpreted\n  include_values_in_response: false // default, // Include updated values in response\n});\n\nconst result = await googleSheets_update_values.action();\n\n// Append Values example\nconst googleSheets_append_values = new GoogleSheetsBubble({\n  operation: \"append_values\", // Append values to the end of a table\n  spreadsheet_id: \"example string\", // Google Sheets spreadsheet ID\n  range: \"example string\", // A1 notation range to search for table (e.g., \"Sheet1!A:A\")\n  values: [[]], // Data to append as array of arrays\n  major_dimension: \"ROWS\" // options: \"ROWS\", \"COLUMNS\", // Major dimension for the values\n  value_input_option: \"RAW\" // options: \"RAW\", \"USER_ENTERED\", // How input data should be interpreted\n  insert_data_option: \"OVERWRITE\" // options: \"OVERWRITE\", \"INSERT_ROWS\", // How data should be inserted\n  include_values_in_response: false // default, // Include appended values in response\n});\n\nconst result = await googleSheets_append_values.action();\n\n// Always check success status before using data\nif (!result.success) {\n  throw new Error(`google-sheets failed: ${result.error}`);\n}\n\n// Access the actual data\nconst actualData = result.data;\nconsole.log(actualData);\n\n// ... and 7 more operations available",
      "requiredCredentials": ["GOOGLE_SHEETS_CRED"]
    },
    {
      "name": "google-calendar",
      "alias": "gcal",
      "type": "service",
      "shortDescription": "Google Calendar integration for managing events",
      "useCase": "- List calendars and events with filters and pagination",
      "inputSchema": "Complex schema - see usage example for structure",
      "outputSchema": "Complex schema - see usage example for structure",
      "usageExample": "// List Calendars example\nconst googleCalendar_list_calendars = new GoogleCalendarBubble({\n  operation: \"list_calendars\", // List calendars for the user\n  max_results: 50 // default, // Maximum number of calendars to return\n  page_token: \"example string\", // Token for fetching next page\n});\n\nconst result = await googleCalendar_list_calendars.action();\n\n// List Events example\nconst googleCalendar_list_events = new GoogleCalendarBubble({\n  operation: \"list_events\", // List events in a calendar\n  calendar_id: \"primary\" // default, // Calendar ID\n  time_min: \"example string\", // Lower bound (RFC3339 timestamp)\n  time_max: \"example string\", // Upper bound (RFC3339 timestamp)\n  q: \"example string\", // Free text search query\n  single_events: true // default, // Expand recurring events\n  order_by: \"startTime\" // options: \"startTime\", \"updated\", // Sort order\n  page_token: \"example string\", // Token for fetching next page\n  max_results: 50 // default, // Maximum number of events to return\n});\n\nconst result = await googleCalendar_list_events.action();\n\n// Get Event example\nconst googleCalendar_get_event = new GoogleCalendarBubble({\n  operation: \"get_event\", // Get a single event\n  calendar_id: \"primary\" // default, // Calendar ID\n  event_id: \"example string\", // Event ID to retrieve\n});\n\nconst result = await googleCalendar_get_event.action();\n\n// Create Event example\nconst googleCalendar_create_event = new GoogleCalendarBubble({\n  operation: \"create_event\", // Create an event\n  calendar_id: \"primary\" // default, // Calendar ID\n  summary: \"example string\", // Event title\n  description: \"example string\", // Event description\n  location: \"example string\", // Event location\n  start: { dateTime: \"example string\" // RFC3339 timestamp, e.g. 2025-09-10T10:00:00-07:00, date: \"example string\" // All-day date in YYYY-MM-DD (mutually exclusive with dateTime), timeZone: \"example string\" // Time zone for the event time }, // Start date/time\n  end: { dateTime: \"example string\" // RFC3339 timestamp, e.g. 2025-09-10T10:00:00-07:00, date: \"example string\" // All-day date in YYYY-MM-DD (mutually exclusive with dateTime), timeZone: \"example string\" // Time zone for the event time }, // End date/time\n  attendees: [{ email: \"example string\" // Attendee email, optional: true // Whether this attendee is optional, responseStatus: \"needsAction\" // options: \"needsAction\", \"declined\", \"tentative\", \"accepted\" // Response status of the attendee, displayName: \"example string\" // Display name of the attendee }], // List of event attendees\n  conference: false // default, // Create a Google Meet conference link\n});\n\nconst result = await googleCalendar_create_event.action();\n\n// Always check success status before using data\nif (!result.success) {\n  throw new Error(`google-calendar failed: ${result.error}`);\n}\n\n// Access the actual data\nconst actualData = result.data;\nconsole.log(actualData);\n\n// ... and 2 more operations available",
      "requiredCredentials": ["GOOGLE_CALENDAR_CRED"]
    },
    {
      "name": "bubbleflow-generator",
      "alias": "generate-flow",
      "type": "workflow",
      "shortDescription": "Generate BubbleFlow code from natural language",
      "useCase": "General purpose bubble for various workflow needs",
      "inputSchema": "{\n  prompt: string // Natural language description of the desired BubbleFlow,\n  credentials: Record<string, string> | undefined // Credentials for AI agent operations\n}",
      "outputSchema": "{\n  generatedCode: string // The generated BubbleFlow TypeScript code,\n  isValid: boolean // Whether the generated code is valid,\n  success: boolean,\n  error: string,\n  toolCalls: unknown[] // The tool calls made by the AI agent,\n  summary: string // High-level instructions for using the validated flow,\n  inputsSchema: string // JSON Schema (string) representing the inputs of the flow\n}",
      "usageExample": "// Example usage of bubbleflow-generator bubble\nconst bubbleflowGenerator = new BubbleflowGeneratorBubble({\n  prompt: \"example string\", // Natural language description of the desired BubbleFlow,\n});\n\nconst result = await bubbleflowGenerator.action();\n\n// Always check success status before using data\nif (!result.success) {\n  throw new Error(`${metadata.name} failed: ${result.error}`);\n}\n\n// Expected output structure in result.data:\n// { generatedCode: \"example string\" // The generated BubbleFlow TypeScript code, isValid: true // Whether the generated code is valid, success: true, error: \"example string\", toolCalls: [] // The tool calls made by the AI agent, summary: \"\" // default // High-level instructions for using the validated flow, inputsSchema: \"\" // default // JSON Schema (string) representing the inputs of the flow }\n\n// Access the actual data\nconst actualData = result.data;\nconsole.log(actualData);",
      "requiredCredentials": ["GOOGLE_GEMINI_CRED", "OPENROUTER_CRED"]
    },
    {
      "name": "database-analyzer",
      "alias": "analyze-db",
      "type": "workflow",
      "shortDescription": "Analyzes database schema structure and metadata",
      "useCase": "General purpose bubble for various workflow needs",
      "inputSchema": "{\n  dataSourceType: \"postgresql\" // Data source type to analyze,\n  ignoreSSLErrors: boolean // Ignore SSL certificate errors,\n  includeMetadata: boolean // Include enum values and column constraints,\n  credentials: Record<string, string> | undefined // Object mapping credential types to values (injected at runtime),\n  injectedMetadata: { tables: Record<string, Record<string, string>> | undefined, tableNotes: Record<string, string> | undefined, rules: string[] | undefined } | undefined // Additional database context injected from user credentials metadata\n}",
      "outputSchema": "{\n  success: boolean,\n  error: string,\n  databaseSchema: { rawData: Record<string, unknown>[] | undefined, cleanedJSON: string | undefined, tableCount: number | undefined, tableNames: string[] | undefined } | undefined,\n  analysisSummary: { dataSourceType: string, connectionSuccessful: boolean, analysisTimestamp: unknown } | undefined\n}",
      "usageExample": "// Example usage of database-analyzer bubble\nconst databaseAnalyzer = new DatabaseAnalyzerBubble({\n  dataSourceType: \"postgresql\", // Data source type to analyze,\n  ignoreSSLErrors: false // default, // Ignore SSL certificate errors,\n  includeMetadata: true // default, // Include enum values and column constraints,\n  injectedMetadata: { tables: { \"example_key\": { \"example_key\": \"example string\" } // record/object with string keys } // record/object with string keys, tableNotes: { \"example_key\": \"example string\" } // record/object with string keys, rules: [\"example string\"] }, // Additional database context injected from user credentials metadata,\n});\n\nconst result = await databaseAnalyzer.action();\n\n// Always check success status before using data\nif (!result.success) {\n  throw new Error(`${metadata.name} failed: ${result.error}`);\n}\n\n// Expected output structure in result.data:\n// { success: true, error: \"example string\", databaseSchema: { rawData: [{} // record/object with string keys], cleanedJSON: \"example string\", tableCount: 42, tableNames: [\"example string\"] }, analysisSummary: { dataSourceType: \"example string\", connectionSuccessful: true } }\n\n// Access the actual data\nconst actualData = result.data;\nconsole.log(actualData);",
      "requiredCredentials": ["DATABASE_CRED"]
    },
    {
      "name": "slack-notifier",
      "alias": "notify-slack",
      "type": "workflow",
      "shortDescription": "Data analyst-powered Slack notifications that tell compelling stories",
      "useCase": "General purpose bubble for various workflow needs",
      "inputSchema": "{\n  contentToFormat: string // Raw content or data to format for Slack,\n  originalUserQuery: string | undefined // Original user question or context,\n  targetChannel: string // Slack channel name (without #) or channel ID,\n  messageTitle: string | undefined // Custom title for the Slack message,\n  messageStyle: \"professional\" | \"casual\" | \"technical\" | \"concise\" | \"detailed\" // Style and tone for message formatting,\n  includeFormatting: boolean // Include emojis and rich Slack formatting,\n  maxMessageLength: number // Maximum message length for Slack,\n  aiModel: { model: \"openai/gpt-5\" | \"openai/gpt-5-mini\" | \"openai/gpt-o4-mini\" | \"openai/gpt-4o\" | \"google/gemini-2.5-pro\" | \"google/gemini-2.5-flash\" | \"google/gemini-2.5-flash-lite\" | \"google/gemini-2.5-flash-image-preview\" | \"anthropic/claude-sonnet-4-5-20250929\", temperature: number, maxTokens: number } | undefined // AI model settings for content formatting,\n  credentials: Record<string, string> | undefined // Object mapping credential types to values (injected at runtime)\n}",
      "outputSchema": "{\n  success: boolean,\n  error: string,\n  messageInfo: { messageTimestamp: string | undefined, channelId: string | undefined, channelName: string | undefined, formattedMessage: string | undefined, messageLength: number | undefined } | undefined,\n  formattingInfo: { modelUsed: string | undefined, wasTruncated: boolean, originalLength: number | undefined } | undefined\n}",
      "usageExample": "// Example usage of slack-notifier bubble\nconst slackNotifier = new SlackNotifierBubble({\n  contentToFormat: \"example string\", // Raw content or data to format for Slack,\n  originalUserQuery: \"example string\", // Original user question or context,\n  targetChannel: \"example string\", // Slack channel name (without #) or channel ID,\n  messageTitle: \"example string\", // Custom title for the Slack message,\n  messageStyle: \"professional\" // options: \"professional\", \"casual\", \"technical\", \"concise\", \"detailed\", // Style and tone for message formatting,\n  includeFormatting: true // default, // Include emojis and rich Slack formatting,\n  maxMessageLength: 3000 // default, // Maximum message length for Slack,\n  aiModel: { model: \"openai/gpt-5\" // options: \"openai/gpt-5\", \"openai/gpt-5-mini\", \"openai/gpt-o4-mini\", \"openai/gpt-4o\", \"google/gemini-2.5-pro\", \"google/gemini-2.5-flash\", \"google/gemini-2.5-flash-lite\", \"google/gemini-2.5-flash-image-preview\", \"anthropic/claude-sonnet-4-5-20250929\", temperature: 0.3 // default, maxTokens: 50000 // default }, // AI model settings for content formatting,\n});\n\nconst result = await slackNotifier.action();\n\n// Always check success status before using data\nif (!result.success) {\n  throw new Error(`${metadata.name} failed: ${result.error}`);\n}\n\n// Expected output structure in result.data:\n// { success: true, error: \"example string\", messageInfo: { messageTimestamp: \"example string\", channelId: \"example string\", channelName: \"example string\", formattedMessage: \"example string\", messageLength: 42 }, formattingInfo: { modelUsed: \"example string\", wasTruncated: false // default, originalLength: 42 } }\n\n// Access the actual data\nconst actualData = result.data;\nconsole.log(actualData);",
      "requiredCredentials": [
        "SLACK_CRED",
        "OPENAI_CRED",
        "GOOGLE_GEMINI_CRED",
        "ANTHROPIC_CRED"
      ]
    },
    {
      "name": "slack-data-assistant",
      "alias": "slack-data-bot",
      "type": "workflow",
      "shortDescription": "AI-powered Slack bot that answers data questions by querying databases",
      "useCase": "General purpose bubble for various workflow needs",
      "inputSchema": "{\n  slackChannel: string // Slack channel ID where the bot will respond,\n  slackThreadTs: string | undefined // Thread timestamp if replying to a thread,\n  userQuestion: string // The user question from Slack,\n  userName: string | undefined // Name of the user asking the question,\n  name: string // Name of the AI assistant (e.g., \"DataBot\", \"Analytics Assistant\"),\n  dataSourceType: \"postgresql\" | \"mysql\" | \"sqlite\" | \"mariadb\" | \"mssql\" // Type of database to analyze,\n  databaseUrl: string | undefined // Database connection URL (if not using credentials),\n  ignoreSSLErrors: boolean // Ignore SSL certificate errors for database connection,\n  aiModel: \"openai/gpt-5\" | \"openai/gpt-5-mini\" | \"openai/gpt-o4-mini\" | \"openai/gpt-4o\" | \"google/gemini-2.5-pro\" | \"google/gemini-2.5-flash\" | \"google/gemini-2.5-flash-lite\" | \"google/gemini-2.5-flash-image-preview\" | \"anthropic/claude-sonnet-4-5-20250929\" // AI model to use for query generation,\n  temperature: number // Temperature for AI responses (lower = more focused),\n  verbosity: \"1\" | \"2\" | \"3\" | \"4\" | \"5\" // Response verbosity level (1=concise, 5=comprehensive),\n  technicality: \"1\" | \"2\" | \"3\" | \"4\" | \"5\" // Technical complexity level (1=plain English, 5=expert),\n  includeQuery: boolean // Include the SQL query in the response,\n  includeExplanation: boolean // Include query explanation in the response,\n  injectedMetadata: { tables: Record<string, Record<string, string>> | undefined, tableNotes: Record<string, string> | undefined, rules: string[] | undefined } | undefined // Additional database context injected from user credentials metadata,\n  additionalContext: string | undefined // Additional context about how to answer the question,\n  maxQueries: number // Maximum number of queries to run,\n  credentials: Record<string, string> | undefined // Credentials for various services\n}",
      "outputSchema": "{\n  success: boolean // Whether the workflow completed successfully,\n  error: string // Error message if workflow failed,\n  query: string | undefined // Generated SQL query,\n  queryExplanation: string | undefined // Explanation of the query,\n  queryResults: Record<string, unknown>[] | undefined // Results from the database query,\n  formattedResponse: string | undefined // Formatted response for Slack,\n  slackBlocks: unknown[] | undefined // Slack block kit formatted message,\n  slackMessageTs: string | undefined // Timestamp of sent Slack message,\n  isDataQuestion: boolean | undefined // Whether the question was data-related,\n  metadata: { executionTime: number, rowCount: number | undefined, wordCount: number | undefined } | undefined\n}",
      "usageExample": "// Example usage of slack-data-assistant bubble\nconst slackDataAssistant = new SlackDataAssistantBubble({\n  slackChannel: \"example string\", // Slack channel ID where the bot will respond,\n  slackThreadTs: \"example string\", // Thread timestamp if replying to a thread,\n  userQuestion: \"example string\", // The user question from Slack,\n  userName: \"example string\", // Name of the user asking the question,\n  name: \"Data Assistant\" // default, // Name of the AI assistant (e.g., \"DataBot\", \"Analytics Assistant\"),\n  dataSourceType: \"postgresql\" // options: \"postgresql\", \"mysql\", \"sqlite\", \"mariadb\", \"mssql\", // Type of database to analyze,\n  databaseUrl: \"example string\", // Database connection URL (if not using credentials),\n  ignoreSSLErrors: false // default, // Ignore SSL certificate errors for database connection,\n  aiModel: \"openai/gpt-5\" // options: \"openai/gpt-5\", \"openai/gpt-5-mini\", \"openai/gpt-o4-mini\", \"openai/gpt-4o\", \"google/gemini-2.5-pro\", \"google/gemini-2.5-flash\", \"google/gemini-2.5-flash-lite\", \"google/gemini-2.5-flash-image-preview\", \"anthropic/claude-sonnet-4-5-20250929\", // AI model to use for query generation,\n  temperature: 0.3 // default, // Temperature for AI responses (lower = more focused),\n  verbosity: \"1\" // options: \"1\", \"2\", \"3\", \"4\", \"5\", // Response verbosity level (1=concise, 5=comprehensive),\n  technicality: \"1\" // options: \"1\", \"2\", \"3\", \"4\", \"5\", // Technical complexity level (1=plain English, 5=expert),\n  includeQuery: true // default, // Include the SQL query in the response,\n  includeExplanation: true // default, // Include query explanation in the response,\n  injectedMetadata: { tables: { \"example_key\": { \"example_key\": \"example string\" } // record/object with string keys } // record/object with string keys, tableNotes: { \"example_key\": \"example string\" } // record/object with string keys, rules: [\"example string\"] }, // Additional database context injected from user credentials metadata,\n  additionalContext: \"example string\", // Additional context about how to answer the question,\n  maxQueries: 20 // default, // Maximum number of queries to run,\n});\n\nconst result = await slackDataAssistant.action();\n\n// Always check success status before using data\nif (!result.success) {\n  throw new Error(`${metadata.name} failed: ${result.error}`);\n}\n\n// Expected output structure in result.data:\n// { success: true // Whether the workflow completed successfully, error: \"example string\" // Error message if workflow failed, query: \"example string\" // Generated SQL query, queryExplanation: \"example string\" // Explanation of the query, queryResults: [{} // record/object with string keys] // Results from the database query, formattedResponse: \"example string\" // Formatted response for Slack, slackBlocks: [] // Slack block kit formatted message, slackMessageTs: \"example string\" // Timestamp of sent Slack message, isDataQuestion: true // Whether the question was data-related, metadata: { executionTime: 42 // Total execution time in milliseconds, rowCount: 42 // Number of rows returned, wordCount: 42 // Word count of response } }\n\n// Access the actual data\nconst actualData = result.data;\nconsole.log(actualData);",
      "requiredCredentials": [
        "DATABASE_CRED",
        "SLACK_CRED",
        "OPENAI_CRED",
        "GOOGLE_GEMINI_CRED",
        "ANTHROPIC_CRED"
      ]
    },
    {
      "name": "slack-formatter-agent",
      "alias": "slack-format",
      "type": "service",
      "shortDescription": "AI agent for creating well-formatted Slack messages with adjustable verbosity and technicality",
      "useCase": "General purpose bubble for various workflow needs",
      "inputSchema": "{\n  message: string // The message or question to send to the AI agent,\n  verbosity: \"1\" | \"2\" | \"3\" | \"4\" | \"5\" // Response verbosity level (1-5): 1=concise bullet points, 5=comprehensive explanations,\n  technicality: \"1\" | \"2\" | \"3\" | \"4\" | \"5\" // Technical complexity level (1-5): 1=plain English, 5=expert terminology,\n  includeBlockKit: boolean // Include Slack Block Kit JSON for rich formatting,\n  includeQuery: boolean // Include the query that was executed in the response,\n  includeExplanation: boolean // Include explanation of what the query does and why it was chosen,\n  model: { model: \"openai/gpt-5\" | \"openai/gpt-5-mini\" | \"openai/gpt-o4-mini\" | \"openai/gpt-4o\" | \"google/gemini-2.5-pro\" | \"google/gemini-2.5-flash\" | \"google/gemini-2.5-flash-lite\" | \"google/gemini-2.5-flash-image-preview\" | \"anthropic/claude-sonnet-4-5-20250929\", temperature: number, maxTokens: number | undefined } // AI model configuration including provider, temperature, and tokens,\n  tools: { name: string, credentials: Record<string, string> | undefined, config: Record<string, unknown> | undefined }[] // Array of tool bubbles the AI agent can use,\n  maxIterations: number // Maximum number of iterations for the agent workflow,\n  credentials: Record<string, string> | undefined // Object mapping credential types to values (injected at runtime),\n  additionalContext: string | undefined // Additional context about how to answer the question\n}",
      "outputSchema": "{\n  response: string // The AI agents formatted response in Slack markdown,\n  blocks: { type: \"section\" | \"header\" | \"divider\" | \"context\" | \"actions\" | \"input\" | \"file\" | \"image\", text: { type: \"plain_text\" | \"mrkdwn\", text: string, emoji: boolean | undefined, verbatim: boolean | undefined } | undefined, block_id: string | undefined, accessory: unknown | undefined, fields: { type: \"plain_text\" | \"mrkdwn\", text: string, emoji: boolean | undefined, verbatim: boolean | undefined }[] | undefined, element: unknown | undefined, label: unknown | undefined, hint: unknown | undefined, optional: boolean | undefined, alt_text: string | undefined, image_url: string | undefined, title: { type: \"plain_text\", text: string, emoji: boolean | undefined } | undefined, elements: { type: \"plain_text\" | \"mrkdwn\", text: string, emoji: boolean | undefined, verbatim: boolean | undefined }[] | undefined }[] | undefined // Slack Block Kit formatted blocks for rich message display,\n  metadata: { verbosityLevel: string, technicalityLevel: string, wordCount: number, blockCount: number | undefined } // Metadata about the formatting,\n  toolCalls: { tool: string, input: unknown, output: unknown }[] | undefined // Array of tool calls made during the conversation,\n  iterations: number // Number of back-and-forth iterations in the agent workflow,\n  error: string // Error message of the run, undefined if successful,\n  success: boolean // Whether the agent execution completed successfully\n}",
      "usageExample": "// Example usage of slack-formatter-agent bubble\nconst slackFormatterAgent = new SlackFormatterAgentBubble({\n  message: \"example string\", // The message or question to send to the AI agent,\n  verbosity: \"1\" // options: \"1\", \"2\", \"3\", \"4\", \"5\", // Response verbosity level (1-5): 1=concise bullet points, 5=comprehensive explanations,\n  technicality: \"1\" // options: \"1\", \"2\", \"3\", \"4\", \"5\", // Technical complexity level (1-5): 1=plain English, 5=expert terminology,\n  includeBlockKit: true // default, // Include Slack Block Kit JSON for rich formatting,\n  includeQuery: false // default, // Include the query that was executed in the response,\n  includeExplanation: false // default, // Include explanation of what the query does and why it was chosen,\n  model: { model: \"openai/gpt-5\" // options: \"openai/gpt-5\", \"openai/gpt-5-mini\", \"openai/gpt-o4-mini\", \"openai/gpt-4o\", \"google/gemini-2.5-pro\", \"google/gemini-2.5-flash\", \"google/gemini-2.5-flash-lite\", \"google/gemini-2.5-flash-image-preview\", \"anthropic/claude-sonnet-4-5-20250929\" // AI model to use (format: provider/model-name), temperature: 0.7 // default // Temperature for response randomness (0 = deterministic, 2 = very random), maxTokens: 10000 // default // Maximum number of tokens to generate in response } // structure, // AI model configuration including provider, temperature, and tokens,\n  tools: [{ name: \"example string\" // Name of the tool bubble to enable for the AI agent, credentials: { \"example_key\": \"example string\" } // record/object with string keys // structure // Credential types to use for the tool bubble (injected at runtime), config: {} // record/object with string keys // Configuration for the tool bubble }] // example for array, // Array of tool bubbles the AI agent can use,\n  maxIterations: 10 // default, // Maximum number of iterations for the agent workflow,\n  additionalContext: \"example string\", // Additional context about how to answer the question,\n});\n\nconst result = await slackFormatterAgent.action();\n\n// Always check success status before using data\nif (!result.success) {\n  throw new Error(`${metadata.name} failed: ${result.error}`);\n}\n\n// Expected output structure in result.data:\n// { response: \"example string\" // The AI agents formatted response in Slack markdown, blocks: [{ type: \"section\" // options: \"section\", \"header\", \"divider\", \"context\", \"actions\", \"input\", \"file\", \"image\", text: { type: \"plain_text\" // options: \"plain_text\", \"mrkdwn\", text: \"example string\", emoji: true, verbatim: true }, block_id: \"example string\", fields: [{ type: \"plain_text\" // options: \"plain_text\", \"mrkdwn\", text: \"example string\", emoji: true, verbatim: true }], optional: true, alt_text: \"example string\", image_url: \"example string\", title: { type: \"plain_text\", text: \"example string\", emoji: true }, elements: [{ type: \"plain_text\" // options: \"plain_text\", \"mrkdwn\", text: \"example string\", emoji: true, verbatim: true }] }] // Slack Block Kit formatted blocks for rich message display, metadata: { verbosityLevel: \"example string\" // Applied verbosity level, technicalityLevel: \"example string\" // Applied technicality level, wordCount: 42 // Total word count of response, blockCount: 42 // Number of Slack blocks generated } // Metadata about the formatting, toolCalls: [{ tool: \"example string\" // Name of the tool that was called }] // Array of tool calls made during the conversation, iterations: 42 // Number of back-and-forth iterations in the agent workflow, error: \"example string\" // Error message of the run, undefined if successful, success: true // Whether the agent execution completed successfully }\n\n// Access the actual data\nconst actualData = result.data;\nconsole.log(actualData);",
      "requiredCredentials": [
        "OPENAI_CRED",
        "GOOGLE_GEMINI_CRED",
        "ANTHROPIC_CRED"
      ]
    },
    {
      "name": "pdf-form-operations",
      "alias": "pdf-forms",
      "type": "workflow",
      "shortDescription": "PDF form field operations (discover, fill, analyze, validate, convert-to-images, convert-to-markdown)",
      "useCase": "General purpose bubble for various workflow needs",
      "inputSchema": "Complex schema - see usage example for structure",
      "outputSchema": "Complex schema - see usage example for structure",
      "usageExample": "// Discover example\nconst pdfFormOperations_discover = new PdfFormOperationsBubble({\n  operation: \"discover\",\n  pdfData: \"example string\", // Base64 encoded PDF data\n  targetPage: 42, // Extract fields from specific page only (default: all pages)\n});\n\nconst result = await pdfFormOperations_discover.action();\n\n// Fill example\nconst pdfFormOperations_fill = new PdfFormOperationsBubble({\n  operation: \"fill\",\n  pdfData: \"example string\", // Base64 encoded PDF data\n  fieldValues: { \"example_key\": \"example string\" } // record/object with string keys, // Field name to value mapping\n});\n\nconst result = await pdfFormOperations_fill.action();\n\n// Analyze-checkboxes example\nconst pdfFormOperations_analyze_checkboxes = new PdfFormOperationsBubble({\n  operation: \"analyze-checkboxes\",\n  pdfData: \"example string\", // Base64 encoded PDF data\n});\n\nconst result = await pdfFormOperations_analyze_checkboxes.action();\n\n// Validate example\nconst pdfFormOperations_validate = new PdfFormOperationsBubble({\n  operation: \"validate\",\n  pdfData: \"example string\", // Base64 encoded PDF data\n});\n\nconst result = await pdfFormOperations_validate.action();\n\n// Always check success status before using data\nif (!result.success) {\n  throw new Error(`pdf-form-operations failed: ${result.error}`);\n}\n\n// Access the actual data\nconst actualData = result.data;\nconsole.log(actualData);\n\n// ... and 2 more operations available",
      "requiredCredentials": []
    },
    {
      "name": "pdf-ocr-workflow",
      "alias": "pdf-ocr",
      "type": "workflow",
      "shortDescription": "PDF OCR workflow: identify fields or autofill forms using AI analysis",
      "useCase": "- **Identify**: Form schema generation, document structure analysis",
      "inputSchema": "Complex schema - see usage example for structure",
      "outputSchema": "Complex schema - see usage example for structure",
      "usageExample": "// Identify example\nconst pdfOcrWorkflow_identify = new PdfOcrWorkflowBubble({\n  mode: \"identify\", // Identify form fields and generate descriptive names\n  pdfData: \"example string\", // Base64 encoded PDF data\n  discoveryOptions: { targetPage: 42 // Extract fields from specific page only (default: all pages) } // structure, // Options for PDF field discovery\n  imageOptions: { format: \"png\" // options: \"png\", \"jpeg\" // Output image format, quality: 0.8 // default // JPEG quality (0.1-1.0, only for JPEG format), dpi: 150 // default // Output DPI (dots per inch), pages: [42] // Specific page numbers to convert (1-indexed). If not provided, converts all pages } // structure, // Options for PDF to images conversion\n  aiOptions: { model: \"openai/gpt-5\" // options: \"openai/gpt-5\", \"openai/gpt-5-mini\", \"openai/gpt-o4-mini\", \"openai/gpt-4o\", \"google/gemini-2.5-pro\", \"google/gemini-2.5-flash\", \"google/gemini-2.5-flash-lite\", \"google/gemini-2.5-flash-image-preview\", \"anthropic/claude-sonnet-4-5-20250929\" // AI model to use for field identification, temperature: 0.3 // default // Temperature for AI responses (lower = more consistent), maxTokens: 50000 // default // Maximum tokens for AI response, jsonMode: true // default // Enable JSON mode to ensure clean JSON output } // structure, // AI agent configuration options\n});\n\nconst result = await pdfOcrWorkflow_identify.action();\n\n// Autofill example\nconst pdfOcrWorkflow_autofill = new PdfOcrWorkflowBubble({\n  mode: \"autofill\", // Identify form fields and autofill with client information\n  pdfData: \"example string\", // Base64 encoded PDF data\n  clientInformation: \"example string\", // Free text containing client information to use for autofilling form fields\n  discoveryOptions: { targetPage: 42 // Extract fields from specific page only (default: all pages) } // structure, // Options for PDF field discovery\n  imageOptions: { format: \"png\" // options: \"png\", \"jpeg\" // Output image format, quality: 0.8 // default // JPEG quality (0.1-1.0, only for JPEG format), dpi: 150 // default // Output DPI (dots per inch), pages: [42] // Specific page numbers to convert (1-indexed). If not provided, converts all pages } // structure, // Options for PDF to images conversion\n  aiOptions: { model: \"openai/gpt-5\" // options: \"openai/gpt-5\", \"openai/gpt-5-mini\", \"openai/gpt-o4-mini\", \"openai/gpt-4o\", \"google/gemini-2.5-pro\", \"google/gemini-2.5-flash\", \"google/gemini-2.5-flash-lite\", \"google/gemini-2.5-flash-image-preview\", \"anthropic/claude-sonnet-4-5-20250929\" // AI model to use for field identification and autofill, temperature: 0.3 // default // Temperature for AI responses (lower = more consistent), maxTokens: 50000 // default // Maximum tokens for AI response, jsonMode: true // default // Enable JSON mode to ensure clean JSON output } // structure, // AI agent configuration options\n});\n\nconst result = await pdfOcrWorkflow_autofill.action();\n\n// Always check success status before using data\nif (!result.success) {\n  throw new Error(`pdf-ocr-workflow failed: ${result.error}`);\n}\n\n// Access the actual data\nconst actualData = result.data;\nconsole.log(actualData);",
      "requiredCredentials": [
        "GOOGLE_GEMINI_CRED",
        "OPENAI_CRED",
        "ANTHROPIC_CRED",
        "OPENROUTER_CRED"
      ]
    },
    {
      "name": "generate-document-workflow",
      "alias": "generate-doc",
      "type": "workflow",
      "shortDescription": "Generate Document workflow: convert markdown to structured formats using AI",
      "useCase": "General purpose bubble for various workflow needs",
      "inputSchema": "{\n  documents: { content: string, index: number, metadata: { originalFilename: string | undefined, pageCount: number | undefined, uploadedImages: { pageNumber: number, fileName: string, fileUrl: string | undefined }[] | undefined } | undefined }[] // Array of document objects with content, index, and metadata,\n  outputDescription: string // Description of what the user wants to extract (e.g., \"expense tracking with vendor, amount, date, category\"),\n  outputFormat: \"html\" | \"csv\" | \"json\" // Output format for the structured data,\n  aiOptions: { model: \"openai/gpt-5\" | \"openai/gpt-5-mini\" | \"openai/gpt-o4-mini\" | \"openai/gpt-4o\" | \"google/gemini-2.5-pro\" | \"google/gemini-2.5-flash\" | \"google/gemini-2.5-flash-lite\" | \"google/gemini-2.5-flash-image-preview\" | \"anthropic/claude-sonnet-4-5-20250929\", temperature: number, maxTokens: number, jsonMode: boolean } // AI agent configuration options,\n  credentials: Record<string, string> | undefined // Credentials for AI model access (GOOGLE_GEMINI_CRED, OPENAI_CRED, etc.)\n}",
      "outputSchema": "{\n  columns: { name: string, type: \"string\" | \"number\" | \"integer\" | \"float\" | \"date\" | \"boolean\", description: string }[] // Column definitions for the structured data,\n  rows: Record<string, unknown>[] // Array of data rows extracted from documents,\n  metadata: { totalDocuments: number, totalRows: number, totalColumns: number, processingTime: number, extractedFrom: string[] } // Metadata about the extraction process,\n  generatedFiles: { html: string | undefined, csv: string | undefined, json: string | undefined } // Generated files in requested formats,\n  aiAnalysis: { model: string, iterations: number, processingTime: number | undefined } // AI analysis metadata,\n  success: boolean // Whether the workflow completed successfully,\n  error: string // Error message if workflow failed\n}",
      "usageExample": "// Example usage of generate-document-workflow bubble\nconst generateDocumentWorkflow = new GenerateDocumentWorkflowBubble({\n  documents: [{ content: \"example string\", index: 42, metadata: { originalFilename: \"example string\", pageCount: 42, uploadedImages: [{ pageNumber: 42, fileName: \"example string\", fileUrl: \"example string\" }] } }], // Array of document objects with content, index, and metadata,\n  outputDescription: \"example string\", // Description of what the user wants to extract (e.g., \"expense tracking with vendor, amount, date, category\"),\n  outputFormat: \"html\" // options: \"html\", \"csv\", \"json\", // Output format for the structured data,\n  aiOptions: { model: \"openai/gpt-5\" // options: \"openai/gpt-5\", \"openai/gpt-5-mini\", \"openai/gpt-o4-mini\", \"openai/gpt-4o\", \"google/gemini-2.5-pro\", \"google/gemini-2.5-flash\", \"google/gemini-2.5-flash-lite\", \"google/gemini-2.5-flash-image-preview\", \"anthropic/claude-sonnet-4-5-20250929\" // AI model to use for document analysis, temperature: 0.1 // default // Temperature for AI responses (lower = more consistent), maxTokens: 50000 // default // Maximum tokens for AI response, jsonMode: true // default // Enable JSON mode to ensure clean JSON output } // structure, // AI agent configuration options,\n});\n\nconst result = await generateDocumentWorkflow.action();\n\n// Always check success status before using data\nif (!result.success) {\n  throw new Error(`${metadata.name} failed: ${result.error}`);\n}\n\n// Expected output structure in result.data:\n// { columns: [{ name: \"example string\" // Column name, type: \"string\" // options: \"string\", \"number\", \"integer\", \"float\", \"date\", \"boolean\" // Data type of the column, description: \"example string\" // Description of what this column contains }] // Column definitions for the structured data, rows: [{} // record/object with string keys] // Array of data rows extracted from documents, metadata: { totalDocuments: 42 // Number of documents processed, totalRows: 42 // Number of data rows extracted, totalColumns: 42 // Number of columns in the result, processingTime: 42 // Processing time in milliseconds, extractedFrom: [\"example string\"] // Summary of document sources } // Metadata about the extraction process, generatedFiles: { html: \"example string\" // Generated HTML table, csv: \"example string\" // Generated CSV data, json: \"example string\" // Generated JSON data } // Generated files in requested formats, aiAnalysis: { model: \"example string\" // AI model used, iterations: 42 // Number of AI iterations, processingTime: 42 // AI processing time } // AI analysis metadata, success: true // Whether the workflow completed successfully, error: \"example string\" // Error message if workflow failed }\n\n// Access the actual data\nconst actualData = result.data;\nconsole.log(actualData);",
      "requiredCredentials": [
        "GOOGLE_GEMINI_CRED",
        "OPENAI_CRED",
        "ANTHROPIC_CRED",
        "OPENROUTER_CRED"
      ]
    },
    {
      "name": "parse-document-workflow",
      "alias": "parse-doc",
      "type": "workflow",
      "shortDescription": "Parse Document workflow: convert PDFs/images to markdown using AI vision",
      "useCase": "General purpose bubble for various workflow needs",
      "inputSchema": "{\n  documentData: string // Base64 encoded document data (PDF or image) OR R2 file URL starting with https://,\n  documentType: \"pdf\" | \"image\" // Type of document being processed,\n  isFileUrl: boolean | undefined // Set to true if documentData is an R2 file URL instead of base64,\n  conversionOptions: { preserveStructure: boolean, includeVisualDescriptions: boolean, extractNumericalData: boolean, combinePages: boolean } // Options for document conversion and parsing,\n  imageOptions: { format: \"png\" | \"jpeg\", quality: number, dpi: number, pages: number[] | undefined } // Options for PDF to images conversion,\n  aiOptions: { model: \"openai/gpt-5\" | \"openai/gpt-5-mini\" | \"openai/gpt-o4-mini\" | \"openai/gpt-4o\" | \"google/gemini-2.5-pro\" | \"google/gemini-2.5-flash\" | \"google/gemini-2.5-flash-lite\" | \"google/gemini-2.5-flash-image-preview\" | \"anthropic/claude-sonnet-4-5-20250929\", temperature: number, maxTokens: number, jsonMode: boolean } // AI agent configuration options,\n  storageOptions: { uploadImages: boolean, bucketName: string | undefined, pageImageUrls: { pageNumber: number, uploadUrl: string, fileName: string }[] | undefined, userId: string | undefined } | undefined // Storage options for uploading page images,\n  credentials: Record<string, string> | undefined // Credentials for AI model access (GOOGLE_GEMINI_CRED, OPENAI_CRED, etc.)\n}",
      "outputSchema": "{\n  markdown: string // Generated markdown content from the document,\n  pages: { pageNumber: number, markdown: string, hasCharts: boolean, hasTables: boolean, hasImages: boolean }[] // Per-page analysis results,\n  metadata: { totalPages: number, processedPages: number, hasVisualElements: boolean, processingTime: number, imageFormat: string, imageDpi: number } // Metadata about the parsing process,\n  conversionSummary: { totalCharacters: number, tablesExtracted: number, chartsDescribed: number, imagesDescribed: number } // Summary of conversion results,\n  aiAnalysis: { model: string, iterations: number, processingTime: number } // AI analysis metadata,\n  uploadedImages: { pageNumber: number, fileName: string, fileUrl: string | undefined, uploaded: boolean }[] | undefined // Information about uploaded page images,\n  success: boolean // Whether the workflow completed successfully,\n  error: string // Error message if workflow failed\n}",
      "usageExample": "// Example usage of parse-document-workflow bubble\nconst parseDocumentWorkflow = new ParseDocumentWorkflowBubble({\n  documentData: \"example string\", // Base64 encoded document data (PDF or image) OR R2 file URL starting with https://,\n  documentType: \"pdf\" // options: \"pdf\", \"image\", // Type of document being processed,\n  isFileUrl: false // default, // Set to true if documentData is an R2 file URL instead of base64,\n  conversionOptions: { preserveStructure: true // default // Maintain original document structure and hierarchy, includeVisualDescriptions: true // default // Include detailed descriptions of charts, images, and diagrams, extractNumericalData: true // default // Extract specific numerical values from charts and tables, combinePages: false // default // Deprecated: Pages are always kept separate with clear headers } // structure, // Options for document conversion and parsing,\n  imageOptions: { format: \"png\" // options: \"png\", \"jpeg\" // Output image format for PDF conversion, quality: 0.9 // default // Image quality (0.1-1.0, higher = better quality), dpi: 200 // default // Output DPI for PDF conversion (higher = better quality), pages: [42] // Specific page numbers to process (1-indexed) } // structure, // Options for PDF to images conversion,\n  aiOptions: { model: \"openai/gpt-5\" // options: \"openai/gpt-5\", \"openai/gpt-5-mini\", \"openai/gpt-o4-mini\", \"openai/gpt-4o\", \"google/gemini-2.5-pro\", \"google/gemini-2.5-flash\", \"google/gemini-2.5-flash-lite\", \"google/gemini-2.5-flash-image-preview\", \"anthropic/claude-sonnet-4-5-20250929\" // AI model to use for document analysis and conversion, temperature: 0.4 // default // Temperature for AI responses (balanced for accuracy vs recitation), maxTokens: 2000 // default // Maximum tokens for AI response, jsonMode: false // default // Use JSON mode for structured output } // structure, // AI agent configuration options,\n  storageOptions: { uploadImages: false // default // Whether to upload converted page images to S3, bucketName: \"example string\" // S3 bucket name for image uploads, pageImageUrls: [{ pageNumber: 42, uploadUrl: \"example string\", fileName: \"example string\" }] // Pre-generated upload URLs for page images, userId: \"example string\" // User ID for secure file isolation }, // Storage options for uploading page images,\n});\n\nconst result = await parseDocumentWorkflow.action();\n\n// Always check success status before using data\nif (!result.success) {\n  throw new Error(`${metadata.name} failed: ${result.error}`);\n}\n\n// Expected output structure in result.data:\n// { markdown: \"example string\" // Generated markdown content from the document, pages: [{ pageNumber: 42 // Page number (1-indexed), markdown: \"example string\" // Markdown content for this page, hasCharts: true // Whether this page contains charts or graphs, hasTables: true // Whether this page contains tables, hasImages: true // Whether this page contains images }] // Per-page analysis results, metadata: { totalPages: 42 // Total number of pages processed, processedPages: 42 // Number of pages successfully processed, hasVisualElements: true // Whether document contains charts, tables, or images, processingTime: 42 // Total processing time in milliseconds, imageFormat: \"example string\" // Image format used for conversion, imageDpi: 42 // DPI used for image conversion } // Metadata about the parsing process, conversionSummary: { totalCharacters: 42 // Total characters in generated markdown, tablesExtracted: 42 // Number of tables converted to markdown, chartsDescribed: 42 // Number of charts and graphs described, imagesDescribed: 42 // Number of images described } // Summary of conversion results, aiAnalysis: { model: \"example string\" // AI model used for analysis, iterations: 42 // Number of AI iterations, processingTime: 42 // AI processing time in milliseconds } // AI analysis metadata, uploadedImages: [{ pageNumber: 42, fileName: \"example string\", fileUrl: \"example string\", uploaded: true }] // Information about uploaded page images, success: true // Whether the workflow completed successfully, error: \"example string\" // Error message if workflow failed }\n\n// Access the actual data\nconst actualData = result.data;\nconsole.log(actualData);",
      "requiredCredentials": [
        "GOOGLE_GEMINI_CRED",
        "OPENAI_CRED",
        "ANTHROPIC_CRED",
        "OPENROUTER_CRED",
        "CLOUDFLARE_R2_ACCESS_KEY",
        "CLOUDFLARE_R2_SECRET_KEY",
        "CLOUDFLARE_R2_ACCOUNT_ID"
      ]
    },
    {
      "name": "get-bubble-details-tool",
      "alias": "details",
      "type": "tool",
      "shortDescription": "Provides detailed information about a specific bubble, including schema, parameters, and documentation",
      "useCase": "- AI agent understanding of specific bubble capabilities",
      "inputSchema": "{\n  bubbleName: string // The name of the bubble to get details about,\n  includeInputSchema: boolean | undefined // Include input parameter schema in the response,\n  credentials: Record<string, string> | undefined // Object mapping credential types to values (injected at runtime)\n}",
      "outputSchema": "{\n  name: string // Name of the bubble,\n  alias: string | undefined // Short alias for the bubble,\n  inputSchema: string | undefined // String representation of the input parameter schema types,\n  outputSchema: string // String representation of the output schema types,\n  usageExample: string // Code example showing how to use the bubble,\n  success: boolean // Whether the operation was successful,\n  error: string // Error message if operation failed\n}",
      "usageExample": "// Example usage of get-bubble-details-tool bubble\nconst getBubbleDetailsTool = new GetBubbleDetailsToolBubble({\n  bubbleName: \"example string\", // The name of the bubble to get details about,\n  includeInputSchema: false // default, // Include input parameter schema in the response,\n});\n\nconst result = await getBubbleDetailsTool.action();\n\n// Always check success status before using data\nif (!result.success) {\n  throw new Error(`${metadata.name} failed: ${result.error}`);\n}\n\n// Expected output structure in result.data:\n// { name: \"example string\" // Name of the bubble, alias: \"example string\" // Short alias for the bubble, inputSchema: \"example string\" // String representation of the input parameter schema types, outputSchema: \"example string\" // String representation of the output schema types, usageExample: \"example string\" // Code example showing how to use the bubble, success: true // Whether the operation was successful, error: \"example string\" // Error message if operation failed }\n\n// Access the actual data\nconst actualData = result.data;\nconsole.log(actualData);",
      "requiredCredentials": []
    },
    {
      "name": "list-bubbles-tool",
      "alias": "list",
      "type": "tool",
      "shortDescription": "Lists all available bubbles in the registry",
      "useCase": "- AI agent discovery of available capabilities",
      "inputSchema": "Complex schema - see usage example for structure",
      "outputSchema": "{\n  bubbles: { name: string, alias: string | undefined, shortDescription: string, useCase: string, type: string }[] // Array of bubble information objects,\n  totalCount: number // Total number of bubbles in the registry,\n  success: boolean // Whether the operation was successful,\n  error: string // Error message if operation failed\n}",
      "usageExample": "// Example usage of list-bubbles-tool bubble\nconst listBubblesTool = new ListBubblesToolBubble({\n  // Add required parameters here\n});\n\nconst result = await listBubblesTool.action();\n\n// Always check success status before using data\nif (!result.success) {\n  throw new Error(`${metadata.name} failed: ${result.error}`);\n}\n\n// Expected output structure in result.data:\n// { bubbles: [{ name: \"example string\" // Name of the bubble, alias: \"example string\" // Short alias for the bubble, shortDescription: \"example string\" // Brief description of the bubble functionality, useCase: \"example string\" // Primary use cases for the bubble, type: \"example string\" // Type of bubble (service, workflow, tool) }] // Array of bubble information objects, totalCount: 42 // Total number of bubbles in the registry, success: true // Whether the operation was successful, error: \"example string\" // Error message if operation failed }\n\n// Access the actual data\nconst actualData = result.data;\nconsole.log(actualData);",
      "requiredCredentials": []
    },
    {
      "name": "sql-query-tool",
      "alias": "sql",
      "type": "tool",
      "shortDescription": "Execute read-only SQL queries against PostgreSQL databases for data analysis",
      "useCase": "- AI agents performing iterative database exploration",
      "inputSchema": "{\n  query: string // SQL query to execute (SELECT, WITH, EXPLAIN, ANALYZE, SHOW, DESCRIBE only),\n  reasoning: string // Explain why you're running this specific query and what you hope to learn from it,\n  credentials: Record<string, string> | undefined // Database credentials (injected at runtime),\n  config: Record<string, unknown> | undefined // Configuration for the tool bubble\n}",
      "outputSchema": "{\n  rows: Record<string, unknown>[] | undefined // Array of query result rows as objects,\n  rowCount: number // Number of rows returned by the query,\n  executionTime: number // Query execution time in milliseconds,\n  fields: { name: string, dataTypeID: number | undefined }[] | undefined // Array of column metadata from the query result,\n  success: boolean // Whether the query execution was successful,\n  error: string // Error message if query execution failed\n}",
      "usageExample": "// Example usage of sql-query-tool bubble\nconst sqlQueryTool = new SqlQueryToolBubble({\n  query: \"example string\", // SQL query to execute (SELECT, WITH, EXPLAIN, ANALYZE, SHOW, DESCRIBE only),\n  reasoning: \"example string\", // Explain why you're running this specific query and what you hope to learn from it,\n  config: {} // record/object with string keys, // Configuration for the tool bubble,\n});\n\nconst result = await sqlQueryTool.action();\n\n// Always check success status before using data\nif (!result.success) {\n  throw new Error(`${metadata.name} failed: ${result.error}`);\n}\n\n// Expected output structure in result.data:\n// { rows: [{} // record/object with string keys] // Array of query result rows as objects, rowCount: 42 // Number of rows returned by the query, executionTime: 42 // Query execution time in milliseconds, fields: [{ name: \"example string\" // Name of the column, dataTypeID: 42 // PostgreSQL data type ID for the column }] // Array of column metadata from the query result, success: true // Whether the query execution was successful, error: \"example string\" // Error message if query execution failed }\n\n// Access the actual data\nconst actualData = result.data;\nconsole.log(actualData);",
      "requiredCredentials": []
    },
    {
      "name": "chart-js-tool",
      "alias": "chart",
      "type": "tool",
      "shortDescription": "Generate Chart.js configurations from data for interactive visualizations",
      "useCase": "- Converting SQL query results into visual charts",
      "inputSchema": "{\n  data: Record<string, unknown>[] // Array of data objects (typically from SQL query results),\n  chartType: \"line\" | \"bar\" | \"pie\" | \"doughnut\" | \"radar\" | \"scatter\" | \"bubble\" | \"polarArea\" // Type of chart to generate,\n  xColumn: string | undefined // Column name to use for X-axis (auto-detected if not provided),\n  yColumn: string | undefined // Column name to use for Y-axis (auto-detected if not provided),\n  groupByColumn: string | undefined // Column to group data by for multiple series,\n  options: { title: string | undefined, xAxisLabel: string | undefined, yAxisLabel: string | undefined, colorScheme: \"default\" | \"viridis\" | \"plasma\" | \"inferno\" | \"magma\" | \"blues\" | \"greens\" | \"reds\" | \"oranges\" | \"categorical\", responsive: boolean, maintainAspectRatio: boolean, showLegend: boolean, showTooltips: boolean } | undefined // Chart customization options,\n  advancedConfig: Record<string, unknown> | undefined // Advanced Chart.js configuration object (overrides simple options),\n  reasoning: string // Explain why this chart type and configuration was chosen,\n  generateFile: boolean // Generate an actual chart image file (PNG format),\n  filePath: string | undefined // Custom file path for generated chart (defaults to temp directory),\n  fileName: string | undefined // Custom file name for generated chart (defaults to auto-generated name),\n  width: number | undefined // Chart width in pixels (default: 800),\n  height: number | undefined // Chart height in pixels (default: 600),\n  credentials: Record<string, string> | undefined // Credentials (HIDDEN from AI - injected at runtime),\n  config: Record<string, unknown> | undefined // Configuration for the tool bubble (HIDDEN from AI - injected at runtime)\n}",
      "outputSchema": "{\n  chartConfig: Record<string, unknown> // Complete Chart.js configuration object,\n  chartType: string // Chart type that was generated,\n  datasetCount: number // Number of datasets in the chart,\n  dataPointCount: number // Total number of data points,\n  suggestedSize: { width: number, height: number } // Suggested canvas size for the chart,\n  metadata: { xColumn: string | undefined, yColumn: string | undefined, groupByColumn: string | undefined, colorScheme: string, generatedAt: string } // Metadata about chart generation,\n  filePath: string | undefined // Path to generated chart file (if generateFile was true),\n  fileExists: boolean | undefined // Whether the generated file exists on disk,\n  fileSize: number | undefined // Size of generated file in bytes,\n  success: boolean,\n  error: string\n}",
      "usageExample": "// Example usage of chart-js-tool bubble\nconst chartJsTool = new ChartJsToolBubble({\n  data: [{} // record/object with string keys], // Array of data objects (typically from SQL query results),\n  chartType: \"line\" // options: \"line\", \"bar\", \"pie\", \"doughnut\", \"radar\", \"scatter\", \"bubble\", \"polarArea\", // Type of chart to generate,\n  xColumn: \"example string\", // Column name to use for X-axis (auto-detected if not provided),\n  yColumn: \"example string\", // Column name to use for Y-axis (auto-detected if not provided),\n  groupByColumn: \"example string\", // Column to group data by for multiple series,\n  options: { title: \"example string\" // Chart title, xAxisLabel: \"example string\" // X-axis label, yAxisLabel: \"example string\" // Y-axis label, colorScheme: \"default\" // options: \"default\", \"viridis\", \"plasma\", \"inferno\", \"magma\", \"blues\", \"greens\", \"reds\", \"oranges\", \"categorical\" // Color scheme for the chart, responsive: true // default // Make chart responsive, maintainAspectRatio: true // default // Maintain aspect ratio, showLegend: true // default // Show chart legend, showTooltips: true // default // Show tooltips on hover }, // Chart customization options,\n  advancedConfig: {} // record/object with string keys, // Advanced Chart.js configuration object (overrides simple options),\n  reasoning: \"example string\", // Explain why this chart type and configuration was chosen,\n  generateFile: false // default, // Generate an actual chart image file (PNG format),\n  filePath: \"example string\", // Custom file path for generated chart (defaults to temp directory),\n  fileName: \"example string\", // Custom file name for generated chart (defaults to auto-generated name),\n  width: 800 // default, // Chart width in pixels (default: 800),\n  height: 600 // default, // Chart height in pixels (default: 600),\n  config: {} // record/object with string keys, // Configuration for the tool bubble (HIDDEN from AI - injected at runtime),\n});\n\nconst result = await chartJsTool.action();\n\n// Always check success status before using data\nif (!result.success) {\n  throw new Error(`${metadata.name} failed: ${result.error}`);\n}\n\n// Expected output structure in result.data:\n// { chartConfig: {} // record/object with string keys // Complete Chart.js configuration object, chartType: \"example string\" // Chart type that was generated, datasetCount: 42 // Number of datasets in the chart, dataPointCount: 42 // Total number of data points, suggestedSize: { width: 42, height: 42 } // Suggested canvas size for the chart, metadata: { xColumn: \"example string\", yColumn: \"example string\", groupByColumn: \"example string\", colorScheme: \"example string\", generatedAt: \"example string\" } // Metadata about chart generation, filePath: \"example string\" // Path to generated chart file (if generateFile was true), fileExists: true // Whether the generated file exists on disk, fileSize: 42 // Size of generated file in bytes, success: true, error: \"example string\" }\n\n// Access the actual data\nconst actualData = result.data;\nconsole.log(actualData);",
      "requiredCredentials": []
    },
    {
      "name": "bubbleflow-validation-tool",
      "alias": "validate-bubbleflow",
      "type": "tool",
      "shortDescription": "Validates BubbleFlow TypeScript code for syntax and structure",
      "useCase": "- When an AI agent needs to validate user-provided BubbleFlow code",
      "inputSchema": "{\n  code: string // TypeScript code to validate,\n  options: { includeDetails: boolean, strictMode: boolean } | undefined // Validation configuration options,\n  credentials: Record<string, string> | undefined // Credentials (HIDDEN from AI - injected at runtime),\n  config: Record<string, unknown> | undefined // Configuration for the validation tool (HIDDEN from AI - injected at runtime)\n}",
      "outputSchema": "{\n  valid: boolean // Whether the code is valid,\n  errors: string[] | undefined // List of validation errors if any,\n  bubbleCount: number | undefined // Number of bubbles found in the code,\n  bubbles: { variableName: string, bubbleName: string, className: string, hasAwait: boolean, hasActionCall: boolean, parameterCount: number }[] | undefined // Details about each bubble found,\n  metadata: { validatedAt: string, codeLength: number, strictMode: boolean },\n  success: boolean // Whether the validation operation was successful,\n  error: string // Error message if validation failed\n}",
      "usageExample": "// Example usage of bubbleflow-validation-tool bubble\nconst bubbleflowValidationTool = new BubbleflowValidationToolBubble({\n  code: \"example string\", // TypeScript code to validate,\n  options: { includeDetails: true // default // Include detailed bubble analysis, strictMode: true // default // Enable strict TypeScript validation }, // Validation configuration options,\n  config: {} // record/object with string keys, // Configuration for the validation tool (HIDDEN from AI - injected at runtime),\n});\n\nconst result = await bubbleflowValidationTool.action();\n\n// Always check success status before using data\nif (!result.success) {\n  throw new Error(`${metadata.name} failed: ${result.error}`);\n}\n\n// Expected output structure in result.data:\n// { valid: true // Whether the code is valid, errors: [\"example string\"] // List of validation errors if any, bubbleCount: 42 // Number of bubbles found in the code, bubbles: [{ variableName: \"example string\" // Variable name assigned to the bubble, bubbleName: \"example string\" // Type of bubble (e.g., postgresql, slack), className: \"example string\" // Bubble class name (e.g., PostgreSQLBubble), hasAwait: true // Whether the bubble call is awaited, hasActionCall: true // Whether .action() is called, parameterCount: 42 // Number of parameters passed to the bubble }] // Details about each bubble found, metadata: { validatedAt: \"example string\" // Timestamp when validation was performed, codeLength: 42 // Length of the code in characters, strictMode: true // Whether strict mode was used }, success: true // Whether the validation operation was successful, error: \"example string\" // Error message if validation failed }\n\n// Access the actual data\nconst actualData = result.data;\nconsole.log(actualData);",
      "requiredCredentials": []
    },
    {
      "name": "web-search-tool",
      "alias": "websearch",
      "type": "tool",
      "shortDescription": "Performs web searches using Firecrawl to find current information from the web",
      "useCase": "- Finding current events and news",
      "inputSchema": "{\n  query: string // The search query to execute,\n  limit: number // Maximum number of search results to return,\n  location: string | undefined // Location parameter for search results (e.g., \"us\", \"uk\"),\n  credentials: Record<string, string> | undefined // Required credentials including FIRECRAWL_API_KEY\n}",
      "outputSchema": "{\n  results: { title: string, url: string, content: string }[] // Array of search results with title, URL, and content,\n  query: string // The original search query,\n  totalResults: number // Number of results returned,\n  searchEngine: string // Search engine used (Firecrawl),\n  success: boolean // Whether the search was successful,\n  error: string // Error message if search failed\n}",
      "usageExample": "// Example usage of web-search-tool bubble\nconst webSearchTool = new WebSearchToolBubble({\n  query: \"example string\", // The search query to execute,\n  limit: 3 // default, // Maximum number of search results to return,\n  location: \"example string\", // Location parameter for search results (e.g., \"us\", \"uk\"),\n});\n\nconst result = await webSearchTool.action();\n\n// Always check success status before using data\nif (!result.success) {\n  throw new Error(`${metadata.name} failed: ${result.error}`);\n}\n\n// Expected output structure in result.data:\n// { results: [{ title: \"example string\" // Title of the search result, url: \"example string\" // URL of the search result, content: \"example string\" // Content snippet from the search result }] // Array of search results with title, URL, and content, query: \"example string\" // The original search query, totalResults: 42 // Number of results returned, searchEngine: \"example string\" // Search engine used (Firecrawl), success: true // Whether the search was successful, error: \"example string\" // Error message if search failed }\n\n// Access the actual data\nconst actualData = result.data;\nconsole.log(actualData);",
      "requiredCredentials": ["FIRECRAWL_API_KEY"]
    },
    {
      "name": "web-scrape-tool",
      "alias": "scrape",
      "type": "tool",
      "shortDescription": "Scrapes content from a single web page using Firecrawl, good to use after web-search-tool to get the full content of a page",
      "useCase": "General purpose bubble for various workflow needs",
      "inputSchema": "{\n  url: string // The URL to scrape content from,\n  format: \"markdown\" // Content format to extract (default: markdown),\n  onlyMainContent: boolean // Extract only main content, filtering out navigation/footers,\n  actions: { type: \"wait\" | \"click\" | \"write\" | \"press\" | \"scroll\" | \"executeJavascript\", milliseconds: number | undefined, selector: string | undefined, text: string | undefined, key: string | undefined, direction: \"up\" | \"down\" | undefined, script: string | undefined }[] | undefined // Optional browser actions for authentication/navigation (e.g., login flows),\n  headers: Record<string, string> | undefined // Optional HTTP headers (e.g., for session cookies),\n  waitFor: number // Time to wait for dynamic content in milliseconds (default: 3000),\n  credentials: Record<string, string> | undefined // Required credentials including FIRECRAWL_API_KEY\n}",
      "outputSchema": "{\n  content: string // Scraped content in requested format,\n  title: string // Page title if available,\n  url: string // The original URL that was scraped,\n  format: string // Format of the returned content,\n  success: boolean // Whether the scraping was successful,\n  error: string // Error message if scraping failed,\n  metadata: { statusCode: number | undefined, loadTime: number | undefined } | undefined // Additional metadata about the scrape\n}",
      "usageExample": "// Example usage of web-scrape-tool bubble\nconst webScrapeTool = new WebScrapeToolBubble({\n  url: \"example string\", // The URL to scrape content from,\n  format: \"markdown\", // Content format to extract (default: markdown),\n  onlyMainContent: true // default, // Extract only main content, filtering out navigation/footers,\n  actions: [{ type: \"wait\" // options: \"wait\", \"click\", \"write\", \"press\", \"scroll\", \"executeJavascript\" // Action type to perform, milliseconds: 42 // Time to wait in milliseconds (for wait), selector: \"example string\" // CSS selector to interact with (wait/click/write/scroll), text: \"example string\" // Text to write (for write), key: \"example string\" // Key to press (e.g., \"Enter\") (for press), direction: \"up\" // options: \"up\", \"down\" // Scroll direction (for scroll), script: \"example string\" // JavaScript code (for executeJavascript) }], // Optional browser actions for authentication/navigation (e.g., login flows),\n  headers: { \"example_key\": \"example string\" } // record/object with string keys, // Optional HTTP headers (e.g., for session cookies),\n  waitFor: 3000 // default, // Time to wait for dynamic content in milliseconds (default: 3000),\n});\n\nconst result = await webScrapeTool.action();\n\n// Always check success status before using data\nif (!result.success) {\n  throw new Error(`${metadata.name} failed: ${result.error}`);\n}\n\n// Expected output structure in result.data:\n// { content: \"example string\" // Scraped content in requested format, title: \"example string\" // Page title if available, url: \"example string\" // The original URL that was scraped, format: \"example string\" // Format of the returned content, success: true // Whether the scraping was successful, error: \"example string\" // Error message if scraping failed, metadata: { statusCode: 42, loadTime: 42 } // Additional metadata about the scrape }\n\n// Access the actual data\nconst actualData = result.data;\nconsole.log(actualData);",
      "requiredCredentials": ["FIRECRAWL_API_KEY"]
    },
    {
      "name": "web-extract-tool",
      "alias": "extract",
      "type": "tool",
      "shortDescription": "Extracts structured data from web pages using Firecrawl AI-powered extraction with custom prompts and schemas",
      "useCase": "General purpose bubble for various workflow needs",
      "inputSchema": "{\n  url: string // The URL to extract structured data from,\n  prompt: string // Detailed prompt describing what data to extract from the web page,\n  schema: string // JSON schema string defining the structure of the data to extract,\n  timeout: number | undefined // Timeout in milliseconds for the extraction (default: 30000),\n  credentials: Record<string, string> | undefined // Required credentials including FIRECRAWL_API_KEY\n}",
      "outputSchema": "{\n  url: string // The original URL that was processed,\n  success: boolean // Whether the extraction was successful,\n  error: string // Error message if extraction failed,\n  extractedData: unknown // The extracted structured data matching the provided schema,\n  metadata: { extractionTime: number | undefined, pageTitle: string | undefined, statusCode: number | undefined } | undefined // Additional metadata about the extraction\n}",
      "usageExample": "// Example usage of web-extract-tool bubble\nconst webExtractTool = new WebExtractToolBubble({\n  url: \"example string\", // The URL to extract structured data from,\n  prompt: \"example string\", // Detailed prompt describing what data to extract from the web page,\n  schema: \"example string\", // JSON schema string defining the structure of the data to extract,\n  timeout: 30000 // default, // Timeout in milliseconds for the extraction (default: 30000),\n});\n\nconst result = await webExtractTool.action();\n\n// Always check success status before using data\nif (!result.success) {\n  throw new Error(`${metadata.name} failed: ${result.error}`);\n}\n\n// Expected output structure in result.data:\n// { url: \"example string\" // The original URL that was processed, success: true // Whether the extraction was successful, error: \"example string\" // Error message if extraction failed, metadata: { extractionTime: 42, pageTitle: \"example string\", statusCode: 42 } // Additional metadata about the extraction }\n\n// Access the actual data\nconst actualData = result.data;\nconsole.log(actualData);",
      "requiredCredentials": ["FIRECRAWL_API_KEY"]
    },
    {
      "name": "research-agent-tool",
      "alias": "research",
      "type": "tool",
      "shortDescription": "AI-powered research agent that searches and scrapes the internet to gather structured information",
      "useCase": "- Market research with structured competitor analysis",
      "inputSchema": "{\n  task: string // The research task that requires searching the internet and gathering information,\n  expectedResultSchema: string // JSON schema string that defines the expected structure of the research result. Out,\n  model: \"openai/gpt-5\" | \"openai/gpt-5-mini\" | \"openai/gpt-o4-mini\" | \"openai/gpt-4o\" | \"google/gemini-2.5-pro\" | \"google/gemini-2.5-flash\" | \"google/gemini-2.5-flash-lite\" | \"google/gemini-2.5-flash-image-preview\" | \"anthropic/claude-sonnet-4-5-20250929\" | undefined // Model to use for the research agent (default: google/gemini-2.5-flash),\n  maxTokens: number | undefined // Maximum number of tokens for the research agent (default: 40000),\n  maxIterations: number // Maximum number of iterations for the research agent (default: 100),\n  credentials: Record<string, string> | undefined // Required credentials\n}",
      "outputSchema": "{\n  result: unknown // The research result matching the expected JSON schema structure, parsed to object,\n  summary: string // 1-2 sentence summary of what research was conducted and completed,\n  sourcesUsed: string[] // Array of URLs and sources that were searched and scraped during research,\n  iterationsUsed: number // Number of AI agent iterations used to complete the research,\n  success: boolean // Whether the research task was completed successfully,\n  error: string // Error message if research failed\n}",
      "usageExample": "// Example usage of research-agent-tool bubble\nconst researchAgentTool = new ResearchAgentToolBubble({\n  task: \"example string\", // The research task that requires searching the internet and gathering information,\n  expectedResultSchema: \"example string\", // JSON schema string that defines the expected structure of the research result. Out,\n  model: \"openai/gpt-5\" // options: \"openai/gpt-5\", \"openai/gpt-5-mini\", \"openai/gpt-o4-mini\", \"openai/gpt-4o\", \"google/gemini-2.5-pro\", \"google/gemini-2.5-flash\", \"google/gemini-2.5-flash-lite\", \"google/gemini-2.5-flash-image-preview\", \"anthropic/claude-sonnet-4-5-20250929\", // Model to use for the research agent (default: google/gemini-2.5-flash),\n  maxTokens: 40000 // default, // Maximum number of tokens for the research agent (default: 40000),\n  maxIterations: 100 // default, // Maximum number of iterations for the research agent (default: 100),\n});\n\nconst result = await researchAgentTool.action();\n\n// Always check success status before using data\nif (!result.success) {\n  throw new Error(`${metadata.name} failed: ${result.error}`);\n}\n\n// Expected output structure in result.data:\n// { summary: \"example string\" // 1-2 sentence summary of what research was conducted and completed, sourcesUsed: [\"example string\"] // Array of URLs and sources that were searched and scraped during research, iterationsUsed: 42 // Number of AI agent iterations used to complete the research, success: true // Whether the research task was completed successfully, error: \"example string\" // Error message if research failed }\n\n// Access the actual data\nconst actualData = result.data;\nconsole.log(actualData);",
      "requiredCredentials": ["FIRECRAWL_API_KEY", "GOOGLE_GEMINI_CRED"]
    },
    {
      "name": "reddit-scrape-tool",
      "alias": "reddit",
      "type": "tool",
      "shortDescription": "Scrapes posts from any Reddit subreddit with flexible filtering and sorting options",
      "useCase": "General purpose bubble for various workflow needs",
      "inputSchema": "{\n  subreddit: string // Name of the subreddit to scrape (without r/ prefix),\n  limit: number // Maximum number of posts to fetch (1-500, default: 25),\n  sort: \"hot\" | \"new\" | \"top\" | \"rising\" // Sorting method for posts (default: hot),\n  timeFilter: \"hour\" | \"day\" | \"week\" | \"month\" | \"year\" | \"all\" | undefined // Time filter for \"top\" sort (only applies when sort=top),\n  filterToday: boolean // Filter results to only include posts from today,\n  includeStickied: boolean // Include stickied/pinned posts in results,\n  minScore: number | undefined // Minimum upvote score required for posts,\n  credentials: Record<string, string> | undefined // Optional credentials for enhanced features\n}",
      "outputSchema": "{\n  posts: { title: string, url: string, author: string, score: number, numComments: number, createdUtc: number, postUrl: string, selftext: string, subreddit: string, postHint: unknown | undefined, isSelf: boolean, thumbnail: string | undefined, domain: string | undefined, flair: string | undefined }[] // Array of scraped Reddit posts,\n  metadata: { subreddit: string, requestedLimit: number, actualCount: number, filteredCount: number, sort: string, timeFilter: string | undefined, scrapedAt: string, apiEndpoint: string } // Metadata about the scraping operation,\n  success: boolean // Whether the scraping was successful,\n  error: string // Error message if scraping failed\n}",
      "usageExample": "// Example usage of reddit-scrape-tool bubble\nconst redditScrapeTool = new RedditScrapeToolBubble({\n  subreddit: \"example string\", // Name of the subreddit to scrape (without r/ prefix),\n  limit: 25 // default, // Maximum number of posts to fetch (1-500, default: 25),\n  sort: \"hot\" // options: \"hot\", \"new\", \"top\", \"rising\", // Sorting method for posts (default: hot),\n  timeFilter: \"hour\" // options: \"hour\", \"day\", \"week\", \"month\", \"year\", \"all\", // Time filter for \"top\" sort (only applies when sort=top),\n  filterToday: false // default, // Filter results to only include posts from today,\n  includeStickied: false // default, // Include stickied/pinned posts in results,\n  minScore: 42, // Minimum upvote score required for posts,\n});\n\nconst result = await redditScrapeTool.action();\n\n// Always check success status before using data\nif (!result.success) {\n  throw new Error(`${metadata.name} failed: ${result.error}`);\n}\n\n// Expected output structure in result.data:\n// { posts: [{ title: \"example string\" // Post title, url: \"example string\" // Post URL (external link or Reddit permalink), author: \"example string\" // Username of the post author, score: 42 // Post upvote score, numComments: 42 // Number of comments on the post, createdUtc: 42 // Post creation timestamp (Unix UTC), postUrl: \"example string\" // Reddit url to the post, selftext: \"example string\" // Post content text (for text posts), subreddit: \"example string\" // Subreddit name, isSelf: true // Whether this is a text post (true) or link post (false), thumbnail: \"example string\" // Thumbnail image URL if available, domain: \"example string\" // Domain of external link, flair: \"example string\" // Post flair text }] // Array of scraped Reddit posts, metadata: { subreddit: \"example string\" // Subreddit that was scraped, requestedLimit: 42 // Number of posts requested, actualCount: 42 // Actual number of posts returned, filteredCount: 42 // Number of posts after filtering, sort: \"example string\" // Sorting method used, timeFilter: \"example string\" // Time filter used (if any), scrapedAt: \"example string\" // ISO timestamp when scraping occurred, apiEndpoint: \"example string\" // Reddit API endpoint used } // Metadata about the scraping operation, success: true // Whether the scraping was successful, error: \"example string\" // Error message if scraping failed }\n\n// Access the actual data\nconst actualData = result.data;\nconsole.log(actualData);",
      "requiredCredentials": []
    },
    {
      "name": "web-crawl-tool",
      "alias": "crawl",
      "type": "tool",
      "shortDescription": "Multi-page web crawling tool for exploring entire websites and subdomains.",
      "useCase": "General purpose bubble for various workflow needs",
      "inputSchema": "{\n  url: string // The root URL to crawl and extract content from,\n  format: \"markdown\" // Output format for crawled content,\n  onlyMainContent: boolean // Extract only main content, filtering out navigation/footers,\n  maxPages: number | undefined // Maximum number of pages to crawl,\n  crawlDepth: number | undefined // Maximum depth to crawl,\n  includePaths: string[] | undefined // URL patterns to include in crawl (regex patterns), Example: [\"^/blog/.*$\", \"^/docs/.*$\"],\n  excludePaths: string[] | undefined // URL patterns to exclude from crawl (regex patterns), [\"^/admin/.*$\", \"^/private/.*$\"],\n  waitFor: number // Time to wait for dynamic content in milliseconds,\n  credentials: Record<string, string> | undefined // Required credentials including FIRECRAWL_API_KEY\n}",
      "outputSchema": "{\n  url: string // The original URL that was crawled,\n  success: boolean // Whether the crawl operation was successful,\n  error: string // Error message if crawl failed,\n  pages: { url: string, title: string | undefined, content: string, depth: number | undefined }[] // Array of crawled pages with content,\n  totalPages: number // Total number of pages crawled,\n  metadata: { loadTime: number | undefined, crawlDepth: number | undefined, maxPagesReached: boolean | undefined } | undefined // Additional metadata about the crawl operation\n}",
      "usageExample": "// Example usage of web-crawl-tool bubble\nconst webCrawlTool = new WebCrawlToolBubble({\n  url: \"example string\", // The root URL to crawl and extract content from,\n  format: \"markdown\", // Output format for crawled content,\n  onlyMainContent: true // default, // Extract only main content, filtering out navigation/footers,\n  maxPages: 10 // default, // Maximum number of pages to crawl,\n  crawlDepth: 2 // default, // Maximum depth to crawl,\n  includePaths: [\"example string\"], // URL patterns to include in crawl (regex patterns), Example: [\"^/blog/.*$\", \"^/docs/.*$\"],\n  excludePaths: [\"example string\"], // URL patterns to exclude from crawl (regex patterns), [\"^/admin/.*$\", \"^/private/.*$\"],\n  waitFor: 3000 // default, // Time to wait for dynamic content in milliseconds,\n});\n\nconst result = await webCrawlTool.action();\n\n// Always check success status before using data\nif (!result.success) {\n  throw new Error(`${metadata.name} failed: ${result.error}`);\n}\n\n// Expected output structure in result.data:\n// { url: \"example string\" // The original URL that was crawled, success: true // Whether the crawl operation was successful, error: \"example string\" // Error message if crawl failed, pages: [{ url: \"example string\", title: \"example string\", content: \"example string\", depth: 42 }] // Array of crawled pages with content, totalPages: 42 // Total number of pages crawled, metadata: { loadTime: 42, crawlDepth: 42, maxPagesReached: true } // Additional metadata about the crawl operation }\n\n// Access the actual data\nconst actualData = result.data;\nconsole.log(actualData);",
      "requiredCredentials": ["FIRECRAWL_API_KEY"]
    },
    {
      "name": "bubbleflow-generator",
      "alias": "generate-flow",
      "type": "workflow",
      "shortDescription": "Generate BubbleFlow code from natural language",
      "useCase": "General purpose bubble for various workflow needs",
      "inputSchema": "{\n  prompt: string // Natural language description of the desired BubbleFlow,\n  credentials: Record<string, string> | undefined // Credentials for AI agent operations\n}",
      "outputSchema": "{\n  generatedCode: string // The generated BubbleFlow TypeScript code,\n  isValid: boolean // Whether the generated code is valid,\n  success: boolean,\n  error: string,\n  toolCalls: unknown[] // The tool calls made by the AI agent,\n  summary: string // High-level instructions for using the validated flow,\n  inputsSchema: string // JSON Schema (string) representing the inputs of the flow\n}",
      "usageExample": "// Example usage of bubbleflow-generator bubble\nconst bubbleflowGenerator = new BubbleflowGeneratorBubble({\n  prompt: \"example string\", // Natural language description of the desired BubbleFlow,\n});\n\nconst result = await bubbleflowGenerator.action();\n\n// Always check success status before using data\nif (!result.success) {\n  throw new Error(`${metadata.name} failed: ${result.error}`);\n}\n\n// Expected output structure in result.data:\n// { generatedCode: \"example string\" // The generated BubbleFlow TypeScript code, isValid: true // Whether the generated code is valid, success: true, error: \"example string\", toolCalls: [] // The tool calls made by the AI agent, summary: \"\" // default // High-level instructions for using the validated flow, inputsSchema: \"\" // default // JSON Schema (string) representing the inputs of the flow }\n\n// Access the actual data\nconst actualData = result.data;\nconsole.log(actualData);",
      "requiredCredentials": ["GOOGLE_GEMINI_CRED", "OPENROUTER_CRED"]
    }
  ]
}
